// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpc_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpc_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpc_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpc_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpc_5fservice_2eproto;
namespace inference {
class CudaSharedMemoryRegisterRequest;
struct CudaSharedMemoryRegisterRequestDefaultTypeInternal;
extern CudaSharedMemoryRegisterRequestDefaultTypeInternal _CudaSharedMemoryRegisterRequest_default_instance_;
class CudaSharedMemoryRegisterResponse;
struct CudaSharedMemoryRegisterResponseDefaultTypeInternal;
extern CudaSharedMemoryRegisterResponseDefaultTypeInternal _CudaSharedMemoryRegisterResponse_default_instance_;
class CudaSharedMemoryStatusRequest;
struct CudaSharedMemoryStatusRequestDefaultTypeInternal;
extern CudaSharedMemoryStatusRequestDefaultTypeInternal _CudaSharedMemoryStatusRequest_default_instance_;
class CudaSharedMemoryStatusResponse;
struct CudaSharedMemoryStatusResponseDefaultTypeInternal;
extern CudaSharedMemoryStatusResponseDefaultTypeInternal _CudaSharedMemoryStatusResponse_default_instance_;
class CudaSharedMemoryStatusResponse_RegionStatus;
struct CudaSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal;
extern CudaSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal _CudaSharedMemoryStatusResponse_RegionStatus_default_instance_;
class CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse;
struct CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal;
extern CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal _CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_;
class CudaSharedMemoryUnregisterRequest;
struct CudaSharedMemoryUnregisterRequestDefaultTypeInternal;
extern CudaSharedMemoryUnregisterRequestDefaultTypeInternal _CudaSharedMemoryUnregisterRequest_default_instance_;
class CudaSharedMemoryUnregisterResponse;
struct CudaSharedMemoryUnregisterResponseDefaultTypeInternal;
extern CudaSharedMemoryUnregisterResponseDefaultTypeInternal _CudaSharedMemoryUnregisterResponse_default_instance_;
class InferInputTensor;
struct InferInputTensorDefaultTypeInternal;
extern InferInputTensorDefaultTypeInternal _InferInputTensor_default_instance_;
class InferInputTensor_ParametersEntry_DoNotUse;
struct InferInputTensor_ParametersEntry_DoNotUseDefaultTypeInternal;
extern InferInputTensor_ParametersEntry_DoNotUseDefaultTypeInternal _InferInputTensor_ParametersEntry_DoNotUse_default_instance_;
class InferOutputTensor;
struct InferOutputTensorDefaultTypeInternal;
extern InferOutputTensorDefaultTypeInternal _InferOutputTensor_default_instance_;
class InferOutputTensor_ParametersEntry_DoNotUse;
struct InferOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal;
extern InferOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal _InferOutputTensor_ParametersEntry_DoNotUse_default_instance_;
class InferParameter;
struct InferParameterDefaultTypeInternal;
extern InferParameterDefaultTypeInternal _InferParameter_default_instance_;
class InferRequestedOutputTensor;
struct InferRequestedOutputTensorDefaultTypeInternal;
extern InferRequestedOutputTensorDefaultTypeInternal _InferRequestedOutputTensor_default_instance_;
class InferRequestedOutputTensor_ParametersEntry_DoNotUse;
struct InferRequestedOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal;
extern InferRequestedOutputTensor_ParametersEntry_DoNotUseDefaultTypeInternal _InferRequestedOutputTensor_ParametersEntry_DoNotUse_default_instance_;
class ModelConfigRequest;
struct ModelConfigRequestDefaultTypeInternal;
extern ModelConfigRequestDefaultTypeInternal _ModelConfigRequest_default_instance_;
class ModelConfigResponse;
struct ModelConfigResponseDefaultTypeInternal;
extern ModelConfigResponseDefaultTypeInternal _ModelConfigResponse_default_instance_;
class ModelInferRequest;
struct ModelInferRequestDefaultTypeInternal;
extern ModelInferRequestDefaultTypeInternal _ModelInferRequest_default_instance_;
class ModelInferRequest_ParametersEntry_DoNotUse;
struct ModelInferRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelInferRequest_ParametersEntry_DoNotUseDefaultTypeInternal _ModelInferRequest_ParametersEntry_DoNotUse_default_instance_;
class ModelInferResponse;
struct ModelInferResponseDefaultTypeInternal;
extern ModelInferResponseDefaultTypeInternal _ModelInferResponse_default_instance_;
class ModelInferResponse_ParametersEntry_DoNotUse;
struct ModelInferResponse_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelInferResponse_ParametersEntry_DoNotUseDefaultTypeInternal _ModelInferResponse_ParametersEntry_DoNotUse_default_instance_;
class ModelMetadataRequest;
struct ModelMetadataRequestDefaultTypeInternal;
extern ModelMetadataRequestDefaultTypeInternal _ModelMetadataRequest_default_instance_;
class ModelMetadataResponse;
struct ModelMetadataResponseDefaultTypeInternal;
extern ModelMetadataResponseDefaultTypeInternal _ModelMetadataResponse_default_instance_;
class ModelMetadataResponse_TensorMetadata;
struct ModelMetadataResponse_TensorMetadataDefaultTypeInternal;
extern ModelMetadataResponse_TensorMetadataDefaultTypeInternal _ModelMetadataResponse_TensorMetadata_default_instance_;
class ModelReadyRequest;
struct ModelReadyRequestDefaultTypeInternal;
extern ModelReadyRequestDefaultTypeInternal _ModelReadyRequest_default_instance_;
class ModelReadyResponse;
struct ModelReadyResponseDefaultTypeInternal;
extern ModelReadyResponseDefaultTypeInternal _ModelReadyResponse_default_instance_;
class ModelStatistics;
struct ModelStatisticsDefaultTypeInternal;
extern ModelStatisticsDefaultTypeInternal _ModelStatistics_default_instance_;
class ModelStatisticsRequest;
struct ModelStatisticsRequestDefaultTypeInternal;
extern ModelStatisticsRequestDefaultTypeInternal _ModelStatisticsRequest_default_instance_;
class ModelStatisticsResponse;
struct ModelStatisticsResponseDefaultTypeInternal;
extern ModelStatisticsResponseDefaultTypeInternal _ModelStatisticsResponse_default_instance_;
class ModelStreamInferRequest;
struct ModelStreamInferRequestDefaultTypeInternal;
extern ModelStreamInferRequestDefaultTypeInternal _ModelStreamInferRequest_default_instance_;
class ModelStreamInferRequest_ParametersEntry_DoNotUse;
struct ModelStreamInferRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelStreamInferRequest_ParametersEntry_DoNotUseDefaultTypeInternal _ModelStreamInferRequest_ParametersEntry_DoNotUse_default_instance_;
class ModelStreamInferResponse;
struct ModelStreamInferResponseDefaultTypeInternal;
extern ModelStreamInferResponseDefaultTypeInternal _ModelStreamInferResponse_default_instance_;
class ModelStreamInferResponse_ParametersEntry_DoNotUse;
struct ModelStreamInferResponse_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelStreamInferResponse_ParametersEntry_DoNotUseDefaultTypeInternal _ModelStreamInferResponse_ParametersEntry_DoNotUse_default_instance_;
class ServerLiveRequest;
struct ServerLiveRequestDefaultTypeInternal;
extern ServerLiveRequestDefaultTypeInternal _ServerLiveRequest_default_instance_;
class ServerLiveResponse;
struct ServerLiveResponseDefaultTypeInternal;
extern ServerLiveResponseDefaultTypeInternal _ServerLiveResponse_default_instance_;
class ServerMetadataRequest;
struct ServerMetadataRequestDefaultTypeInternal;
extern ServerMetadataRequestDefaultTypeInternal _ServerMetadataRequest_default_instance_;
class ServerMetadataResponse;
struct ServerMetadataResponseDefaultTypeInternal;
extern ServerMetadataResponseDefaultTypeInternal _ServerMetadataResponse_default_instance_;
class ServerReadyRequest;
struct ServerReadyRequestDefaultTypeInternal;
extern ServerReadyRequestDefaultTypeInternal _ServerReadyRequest_default_instance_;
class ServerReadyResponse;
struct ServerReadyResponseDefaultTypeInternal;
extern ServerReadyResponseDefaultTypeInternal _ServerReadyResponse_default_instance_;
class SystemSharedMemoryRegisterRequest;
struct SystemSharedMemoryRegisterRequestDefaultTypeInternal;
extern SystemSharedMemoryRegisterRequestDefaultTypeInternal _SystemSharedMemoryRegisterRequest_default_instance_;
class SystemSharedMemoryRegisterResponse;
struct SystemSharedMemoryRegisterResponseDefaultTypeInternal;
extern SystemSharedMemoryRegisterResponseDefaultTypeInternal _SystemSharedMemoryRegisterResponse_default_instance_;
class SystemSharedMemoryStatusRequest;
struct SystemSharedMemoryStatusRequestDefaultTypeInternal;
extern SystemSharedMemoryStatusRequestDefaultTypeInternal _SystemSharedMemoryStatusRequest_default_instance_;
class SystemSharedMemoryStatusResponse;
struct SystemSharedMemoryStatusResponseDefaultTypeInternal;
extern SystemSharedMemoryStatusResponseDefaultTypeInternal _SystemSharedMemoryStatusResponse_default_instance_;
class SystemSharedMemoryStatusResponse_RegionStatus;
struct SystemSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal;
extern SystemSharedMemoryStatusResponse_RegionStatusDefaultTypeInternal _SystemSharedMemoryStatusResponse_RegionStatus_default_instance_;
class SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse;
struct SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal;
extern SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUseDefaultTypeInternal _SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_;
class SystemSharedMemoryUnregisterRequest;
struct SystemSharedMemoryUnregisterRequestDefaultTypeInternal;
extern SystemSharedMemoryUnregisterRequestDefaultTypeInternal _SystemSharedMemoryUnregisterRequest_default_instance_;
class SystemSharedMemoryUnregisterResponse;
struct SystemSharedMemoryUnregisterResponseDefaultTypeInternal;
extern SystemSharedMemoryUnregisterResponseDefaultTypeInternal _SystemSharedMemoryUnregisterResponse_default_instance_;
}  // namespace inference
PROTOBUF_NAMESPACE_OPEN
template<> ::inference::CudaSharedMemoryRegisterRequest* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryRegisterRequest>(Arena*);
template<> ::inference::CudaSharedMemoryRegisterResponse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryRegisterResponse>(Arena*);
template<> ::inference::CudaSharedMemoryStatusRequest* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusRequest>(Arena*);
template<> ::inference::CudaSharedMemoryStatusResponse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusResponse>(Arena*);
template<> ::inference::CudaSharedMemoryStatusResponse_RegionStatus* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusResponse_RegionStatus>(Arena*);
template<> ::inference::CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse>(Arena*);
template<> ::inference::CudaSharedMemoryUnregisterRequest* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryUnregisterRequest>(Arena*);
template<> ::inference::CudaSharedMemoryUnregisterResponse* Arena::CreateMaybeMessage<::inference::CudaSharedMemoryUnregisterResponse>(Arena*);
template<> ::inference::InferInputTensor* Arena::CreateMaybeMessage<::inference::InferInputTensor>(Arena*);
template<> ::inference::InferInputTensor_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::InferInputTensor_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::InferOutputTensor* Arena::CreateMaybeMessage<::inference::InferOutputTensor>(Arena*);
template<> ::inference::InferOutputTensor_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::InferOutputTensor_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::InferParameter* Arena::CreateMaybeMessage<::inference::InferParameter>(Arena*);
template<> ::inference::InferRequestedOutputTensor* Arena::CreateMaybeMessage<::inference::InferRequestedOutputTensor>(Arena*);
template<> ::inference::InferRequestedOutputTensor_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::InferRequestedOutputTensor_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelConfigRequest* Arena::CreateMaybeMessage<::inference::ModelConfigRequest>(Arena*);
template<> ::inference::ModelConfigResponse* Arena::CreateMaybeMessage<::inference::ModelConfigResponse>(Arena*);
template<> ::inference::ModelInferRequest* Arena::CreateMaybeMessage<::inference::ModelInferRequest>(Arena*);
template<> ::inference::ModelInferRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelInferRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelInferResponse* Arena::CreateMaybeMessage<::inference::ModelInferResponse>(Arena*);
template<> ::inference::ModelInferResponse_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelInferResponse_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelMetadataRequest* Arena::CreateMaybeMessage<::inference::ModelMetadataRequest>(Arena*);
template<> ::inference::ModelMetadataResponse* Arena::CreateMaybeMessage<::inference::ModelMetadataResponse>(Arena*);
template<> ::inference::ModelMetadataResponse_TensorMetadata* Arena::CreateMaybeMessage<::inference::ModelMetadataResponse_TensorMetadata>(Arena*);
template<> ::inference::ModelReadyRequest* Arena::CreateMaybeMessage<::inference::ModelReadyRequest>(Arena*);
template<> ::inference::ModelReadyResponse* Arena::CreateMaybeMessage<::inference::ModelReadyResponse>(Arena*);
template<> ::inference::ModelStatistics* Arena::CreateMaybeMessage<::inference::ModelStatistics>(Arena*);
template<> ::inference::ModelStatisticsRequest* Arena::CreateMaybeMessage<::inference::ModelStatisticsRequest>(Arena*);
template<> ::inference::ModelStatisticsResponse* Arena::CreateMaybeMessage<::inference::ModelStatisticsResponse>(Arena*);
template<> ::inference::ModelStreamInferRequest* Arena::CreateMaybeMessage<::inference::ModelStreamInferRequest>(Arena*);
template<> ::inference::ModelStreamInferRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelStreamInferRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelStreamInferResponse* Arena::CreateMaybeMessage<::inference::ModelStreamInferResponse>(Arena*);
template<> ::inference::ModelStreamInferResponse_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelStreamInferResponse_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ServerLiveRequest* Arena::CreateMaybeMessage<::inference::ServerLiveRequest>(Arena*);
template<> ::inference::ServerLiveResponse* Arena::CreateMaybeMessage<::inference::ServerLiveResponse>(Arena*);
template<> ::inference::ServerMetadataRequest* Arena::CreateMaybeMessage<::inference::ServerMetadataRequest>(Arena*);
template<> ::inference::ServerMetadataResponse* Arena::CreateMaybeMessage<::inference::ServerMetadataResponse>(Arena*);
template<> ::inference::ServerReadyRequest* Arena::CreateMaybeMessage<::inference::ServerReadyRequest>(Arena*);
template<> ::inference::ServerReadyResponse* Arena::CreateMaybeMessage<::inference::ServerReadyResponse>(Arena*);
template<> ::inference::SystemSharedMemoryRegisterRequest* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryRegisterRequest>(Arena*);
template<> ::inference::SystemSharedMemoryRegisterResponse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryRegisterResponse>(Arena*);
template<> ::inference::SystemSharedMemoryStatusRequest* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusRequest>(Arena*);
template<> ::inference::SystemSharedMemoryStatusResponse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusResponse>(Arena*);
template<> ::inference::SystemSharedMemoryStatusResponse_RegionStatus* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusResponse_RegionStatus>(Arena*);
template<> ::inference::SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse>(Arena*);
template<> ::inference::SystemSharedMemoryUnregisterRequest* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryUnregisterRequest>(Arena*);
template<> ::inference::SystemSharedMemoryUnregisterResponse* Arena::CreateMaybeMessage<::inference::SystemSharedMemoryUnregisterResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace inference {

// ===================================================================

class ServerLiveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.ServerLiveRequest) */ {
 public:
  inline ServerLiveRequest() : ServerLiveRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ServerLiveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerLiveRequest(const ServerLiveRequest& from);
  ServerLiveRequest(ServerLiveRequest&& from) noexcept
    : ServerLiveRequest() {
    *this = ::std::move(from);
  }

  inline ServerLiveRequest& operator=(const ServerLiveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerLiveRequest& operator=(ServerLiveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerLiveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerLiveRequest* internal_default_instance() {
    return reinterpret_cast<const ServerLiveRequest*>(
               &_ServerLiveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServerLiveRequest& a, ServerLiveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerLiveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerLiveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerLiveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerLiveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServerLiveRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServerLiveRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerLiveRequest";
  }
  protected:
  explicit ServerLiveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ServerLiveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerLiveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ServerLiveResponse) */ {
 public:
  inline ServerLiveResponse() : ServerLiveResponse(nullptr) {}
  ~ServerLiveResponse() override;
  explicit PROTOBUF_CONSTEXPR ServerLiveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerLiveResponse(const ServerLiveResponse& from);
  ServerLiveResponse(ServerLiveResponse&& from) noexcept
    : ServerLiveResponse() {
    *this = ::std::move(from);
  }

  inline ServerLiveResponse& operator=(const ServerLiveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerLiveResponse& operator=(ServerLiveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerLiveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerLiveResponse* internal_default_instance() {
    return reinterpret_cast<const ServerLiveResponse*>(
               &_ServerLiveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerLiveResponse& a, ServerLiveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerLiveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerLiveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerLiveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerLiveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerLiveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerLiveResponse& from) {
    ServerLiveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerLiveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerLiveResponse";
  }
  protected:
  explicit ServerLiveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveFieldNumber = 1,
  };
  // bool live = 1;
  void clear_live();
  bool live() const;
  void set_live(bool value);
  private:
  bool _internal_live() const;
  void _internal_set_live(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ServerLiveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool live_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerReadyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.ServerReadyRequest) */ {
 public:
  inline ServerReadyRequest() : ServerReadyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ServerReadyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerReadyRequest(const ServerReadyRequest& from);
  ServerReadyRequest(ServerReadyRequest&& from) noexcept
    : ServerReadyRequest() {
    *this = ::std::move(from);
  }

  inline ServerReadyRequest& operator=(const ServerReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerReadyRequest& operator=(ServerReadyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerReadyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerReadyRequest* internal_default_instance() {
    return reinterpret_cast<const ServerReadyRequest*>(
               &_ServerReadyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServerReadyRequest& a, ServerReadyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerReadyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerReadyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerReadyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerReadyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServerReadyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServerReadyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerReadyRequest";
  }
  protected:
  explicit ServerReadyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ServerReadyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerReadyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ServerReadyResponse) */ {
 public:
  inline ServerReadyResponse() : ServerReadyResponse(nullptr) {}
  ~ServerReadyResponse() override;
  explicit PROTOBUF_CONSTEXPR ServerReadyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerReadyResponse(const ServerReadyResponse& from);
  ServerReadyResponse(ServerReadyResponse&& from) noexcept
    : ServerReadyResponse() {
    *this = ::std::move(from);
  }

  inline ServerReadyResponse& operator=(const ServerReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerReadyResponse& operator=(ServerReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerReadyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerReadyResponse* internal_default_instance() {
    return reinterpret_cast<const ServerReadyResponse*>(
               &_ServerReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServerReadyResponse& a, ServerReadyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerReadyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerReadyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerReadyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerReadyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerReadyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerReadyResponse& from) {
    ServerReadyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerReadyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerReadyResponse";
  }
  protected:
  explicit ServerReadyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ServerReadyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelReadyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelReadyRequest) */ {
 public:
  inline ModelReadyRequest() : ModelReadyRequest(nullptr) {}
  ~ModelReadyRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelReadyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelReadyRequest(const ModelReadyRequest& from);
  ModelReadyRequest(ModelReadyRequest&& from) noexcept
    : ModelReadyRequest() {
    *this = ::std::move(from);
  }

  inline ModelReadyRequest& operator=(const ModelReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelReadyRequest& operator=(ModelReadyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelReadyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelReadyRequest* internal_default_instance() {
    return reinterpret_cast<const ModelReadyRequest*>(
               &_ModelReadyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModelReadyRequest& a, ModelReadyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelReadyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelReadyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelReadyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelReadyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelReadyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelReadyRequest& from) {
    ModelReadyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelReadyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelReadyRequest";
  }
  protected:
  explicit ModelReadyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelReadyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelReadyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelReadyResponse) */ {
 public:
  inline ModelReadyResponse() : ModelReadyResponse(nullptr) {}
  ~ModelReadyResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelReadyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelReadyResponse(const ModelReadyResponse& from);
  ModelReadyResponse(ModelReadyResponse&& from) noexcept
    : ModelReadyResponse() {
    *this = ::std::move(from);
  }

  inline ModelReadyResponse& operator=(const ModelReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelReadyResponse& operator=(ModelReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelReadyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelReadyResponse* internal_default_instance() {
    return reinterpret_cast<const ModelReadyResponse*>(
               &_ModelReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModelReadyResponse& a, ModelReadyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelReadyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelReadyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelReadyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelReadyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelReadyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelReadyResponse& from) {
    ModelReadyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelReadyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelReadyResponse";
  }
  protected:
  explicit ModelReadyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelReadyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.ServerMetadataRequest) */ {
 public:
  inline ServerMetadataRequest() : ServerMetadataRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ServerMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMetadataRequest(const ServerMetadataRequest& from);
  ServerMetadataRequest(ServerMetadataRequest&& from) noexcept
    : ServerMetadataRequest() {
    *this = ::std::move(from);
  }

  inline ServerMetadataRequest& operator=(const ServerMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMetadataRequest& operator=(ServerMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const ServerMetadataRequest*>(
               &_ServerMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ServerMetadataRequest& a, ServerMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServerMetadataRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServerMetadataRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerMetadataRequest";
  }
  protected:
  explicit ServerMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ServerMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ServerMetadataResponse) */ {
 public:
  inline ServerMetadataResponse() : ServerMetadataResponse(nullptr) {}
  ~ServerMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR ServerMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMetadataResponse(const ServerMetadataResponse& from);
  ServerMetadataResponse(ServerMetadataResponse&& from) noexcept
    : ServerMetadataResponse() {
    *this = ::std::move(from);
  }

  inline ServerMetadataResponse& operator=(const ServerMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMetadataResponse& operator=(ServerMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const ServerMetadataResponse*>(
               &_ServerMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ServerMetadataResponse& a, ServerMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMetadataResponse& from) {
    ServerMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ServerMetadataResponse";
  }
  protected:
  explicit ServerMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 3,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // repeated string extensions = 3;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  const std::string& extensions(int index) const;
  std::string* mutable_extensions(int index);
  void set_extensions(int index, const std::string& value);
  void set_extensions(int index, std::string&& value);
  void set_extensions(int index, const char* value);
  void set_extensions(int index, const char* value, size_t size);
  std::string* add_extensions();
  void add_extensions(const std::string& value);
  void add_extensions(std::string&& value);
  void add_extensions(const char* value);
  void add_extensions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& extensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_extensions();
  private:
  const std::string& _internal_extensions(int index) const;
  std::string* _internal_add_extensions();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ServerMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelMetadataRequest) */ {
 public:
  inline ModelMetadataRequest() : ModelMetadataRequest(nullptr) {}
  ~ModelMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetadataRequest(const ModelMetadataRequest& from);
  ModelMetadataRequest(ModelMetadataRequest&& from) noexcept
    : ModelMetadataRequest() {
    *this = ::std::move(from);
  }

  inline ModelMetadataRequest& operator=(const ModelMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetadataRequest& operator=(ModelMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const ModelMetadataRequest*>(
               &_ModelMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ModelMetadataRequest& a, ModelMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetadataRequest& from) {
    ModelMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelMetadataRequest";
  }
  protected:
  explicit ModelMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelMetadataResponse) */ {
 public:
  inline ModelMetadataResponse() : ModelMetadataResponse(nullptr) {}
  ~ModelMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetadataResponse(const ModelMetadataResponse& from);
  ModelMetadataResponse(ModelMetadataResponse&& from) noexcept
    : ModelMetadataResponse() {
    *this = ::std::move(from);
  }

  inline ModelMetadataResponse& operator=(const ModelMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetadataResponse& operator=(ModelMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const ModelMetadataResponse*>(
               &_ModelMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModelMetadataResponse& a, ModelMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetadataResponse& from) {
    ModelMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelMetadataResponse";
  }
  protected:
  explicit ModelMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 2,
    kInputsFieldNumber = 4,
    kOutputsFieldNumber = 5,
    kNameFieldNumber = 1,
    kPlatformFieldNumber = 3,
  };
  // repeated string versions = 2;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // repeated .inference.ModelMetadataResponse_TensorMetadata inputs = 4;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::inference::ModelMetadataResponse_TensorMetadata* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
      mutable_inputs();
  private:
  const ::inference::ModelMetadataResponse_TensorMetadata& _internal_inputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* _internal_add_inputs();
  public:
  const ::inference::ModelMetadataResponse_TensorMetadata& inputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
      inputs() const;

  // repeated .inference.ModelMetadataResponse_TensorMetadata outputs = 5;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::ModelMetadataResponse_TensorMetadata* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
      mutable_outputs();
  private:
  const ::inference::ModelMetadataResponse_TensorMetadata& _internal_outputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* _internal_add_outputs();
  public:
  const ::inference::ModelMetadataResponse_TensorMetadata& outputs(int index) const;
  ::inference::ModelMetadataResponse_TensorMetadata* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
      outputs() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string platform = 3;
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata > outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetadataResponse_TensorMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelMetadataResponse_TensorMetadata) */ {
 public:
  inline ModelMetadataResponse_TensorMetadata() : ModelMetadataResponse_TensorMetadata(nullptr) {}
  ~ModelMetadataResponse_TensorMetadata() override;
  explicit PROTOBUF_CONSTEXPR ModelMetadataResponse_TensorMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetadataResponse_TensorMetadata(const ModelMetadataResponse_TensorMetadata& from);
  ModelMetadataResponse_TensorMetadata(ModelMetadataResponse_TensorMetadata&& from) noexcept
    : ModelMetadataResponse_TensorMetadata() {
    *this = ::std::move(from);
  }

  inline ModelMetadataResponse_TensorMetadata& operator=(const ModelMetadataResponse_TensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetadataResponse_TensorMetadata& operator=(ModelMetadataResponse_TensorMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetadataResponse_TensorMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetadataResponse_TensorMetadata* internal_default_instance() {
    return reinterpret_cast<const ModelMetadataResponse_TensorMetadata*>(
               &_ModelMetadataResponse_TensorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModelMetadataResponse_TensorMetadata& a, ModelMetadataResponse_TensorMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetadataResponse_TensorMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetadataResponse_TensorMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetadataResponse_TensorMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetadataResponse_TensorMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetadataResponse_TensorMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetadataResponse_TensorMetadata& from) {
    ModelMetadataResponse_TensorMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetadataResponse_TensorMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelMetadataResponse_TensorMetadata";
  }
  protected:
  explicit ModelMetadataResponse_TensorMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kNameFieldNumber = 1,
    kDatatypeFieldNumber = 2,
  };
  // repeated int64 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string datatype = 2;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelMetadataResponse_TensorMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelConfigRequest) */ {
 public:
  inline ModelConfigRequest() : ModelConfigRequest(nullptr) {}
  ~ModelConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelConfigRequest(const ModelConfigRequest& from);
  ModelConfigRequest(ModelConfigRequest&& from) noexcept
    : ModelConfigRequest() {
    *this = ::std::move(from);
  }

  inline ModelConfigRequest& operator=(const ModelConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfigRequest& operator=(ModelConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ModelConfigRequest*>(
               &_ModelConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ModelConfigRequest& a, ModelConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelConfigRequest& from) {
    ModelConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelConfigRequest";
  }
  protected:
  explicit ModelConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelConfigResponse) */ {
 public:
  inline ModelConfigResponse() : ModelConfigResponse(nullptr) {}
  ~ModelConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelConfigResponse(const ModelConfigResponse& from);
  ModelConfigResponse(ModelConfigResponse&& from) noexcept
    : ModelConfigResponse() {
    *this = ::std::move(from);
  }

  inline ModelConfigResponse& operator=(const ModelConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfigResponse& operator=(ModelConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ModelConfigResponse*>(
               &_ModelConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ModelConfigResponse& a, ModelConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelConfigResponse& from) {
    ModelConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelConfigResponse";
  }
  protected:
  explicit ModelConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // string config = 1;
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_NODISCARD std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStatisticsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStatisticsRequest) */ {
 public:
  inline ModelStatisticsRequest() : ModelStatisticsRequest(nullptr) {}
  ~ModelStatisticsRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelStatisticsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStatisticsRequest(const ModelStatisticsRequest& from);
  ModelStatisticsRequest(ModelStatisticsRequest&& from) noexcept
    : ModelStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline ModelStatisticsRequest& operator=(const ModelStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStatisticsRequest& operator=(ModelStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const ModelStatisticsRequest*>(
               &_ModelStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ModelStatisticsRequest& a, ModelStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStatisticsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStatisticsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStatisticsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStatisticsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStatisticsRequest& from) {
    ModelStatisticsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStatisticsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStatisticsRequest";
  }
  protected:
  explicit ModelStatisticsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelStatisticsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStatisticsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStatisticsResponse) */ {
 public:
  inline ModelStatisticsResponse() : ModelStatisticsResponse(nullptr) {}
  ~ModelStatisticsResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelStatisticsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStatisticsResponse(const ModelStatisticsResponse& from);
  ModelStatisticsResponse(ModelStatisticsResponse&& from) noexcept
    : ModelStatisticsResponse() {
    *this = ::std::move(from);
  }

  inline ModelStatisticsResponse& operator=(const ModelStatisticsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStatisticsResponse& operator=(ModelStatisticsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStatisticsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStatisticsResponse* internal_default_instance() {
    return reinterpret_cast<const ModelStatisticsResponse*>(
               &_ModelStatisticsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ModelStatisticsResponse& a, ModelStatisticsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStatisticsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStatisticsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStatisticsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStatisticsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStatisticsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStatisticsResponse& from) {
    ModelStatisticsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStatisticsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStatisticsResponse";
  }
  protected:
  explicit ModelStatisticsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelStatsFieldNumber = 1,
  };
  // repeated .inference.ModelStatistics model_stats = 1;
  int model_stats_size() const;
  private:
  int _internal_model_stats_size() const;
  public:
  void clear_model_stats();
  ::inference::ModelStatistics* mutable_model_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >*
      mutable_model_stats();
  private:
  const ::inference::ModelStatistics& _internal_model_stats(int index) const;
  ::inference::ModelStatistics* _internal_add_model_stats();
  public:
  const ::inference::ModelStatistics& model_stats(int index) const;
  ::inference::ModelStatistics* add_model_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >&
      model_stats() const;

  // @@protoc_insertion_point(class_scope:inference.ModelStatisticsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics > model_stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStatistics) */ {
 public:
  inline ModelStatistics() : ModelStatistics(nullptr) {}
  ~ModelStatistics() override;
  explicit PROTOBUF_CONSTEXPR ModelStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStatistics(const ModelStatistics& from);
  ModelStatistics(ModelStatistics&& from) noexcept
    : ModelStatistics() {
    *this = ::std::move(from);
  }

  inline ModelStatistics& operator=(const ModelStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStatistics& operator=(ModelStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStatistics* internal_default_instance() {
    return reinterpret_cast<const ModelStatistics*>(
               &_ModelStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ModelStatistics& a, ModelStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStatistics& from) {
    ModelStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStatistics";
  }
  protected:
  explicit ModelStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kLastInferenceFieldNumber = 3,
    kInferenceCountFieldNumber = 4,
    kExecutionCountFieldNumber = 5,
    kInferenceDurationNsFieldNumber = 6,
    kQueueDurationNsFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 last_inference = 3;
  void clear_last_inference();
  uint64_t last_inference() const;
  void set_last_inference(uint64_t value);
  private:
  uint64_t _internal_last_inference() const;
  void _internal_set_last_inference(uint64_t value);
  public:

  // uint64 inference_count = 4;
  void clear_inference_count();
  uint64_t inference_count() const;
  void set_inference_count(uint64_t value);
  private:
  uint64_t _internal_inference_count() const;
  void _internal_set_inference_count(uint64_t value);
  public:

  // uint64 execution_count = 5;
  void clear_execution_count();
  uint64_t execution_count() const;
  void set_execution_count(uint64_t value);
  private:
  uint64_t _internal_execution_count() const;
  void _internal_set_execution_count(uint64_t value);
  public:

  // uint64 inference_duration_ns = 6;
  void clear_inference_duration_ns();
  uint64_t inference_duration_ns() const;
  void set_inference_duration_ns(uint64_t value);
  private:
  uint64_t _internal_inference_duration_ns() const;
  void _internal_set_inference_duration_ns(uint64_t value);
  public:

  // uint64 queue_duration_ns = 7;
  void clear_queue_duration_ns();
  uint64_t queue_duration_ns() const;
  void set_queue_duration_ns(uint64_t value);
  private:
  uint64_t _internal_queue_duration_ns() const;
  void _internal_set_queue_duration_ns(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint64_t last_inference_;
    uint64_t inference_count_;
    uint64_t execution_count_;
    uint64_t inference_duration_ns_;
    uint64_t queue_duration_ns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryStatusRequest) */ {
 public:
  inline SystemSharedMemoryStatusRequest() : SystemSharedMemoryStatusRequest(nullptr) {}
  ~SystemSharedMemoryStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryStatusRequest(const SystemSharedMemoryStatusRequest& from);
  SystemSharedMemoryStatusRequest(SystemSharedMemoryStatusRequest&& from) noexcept
    : SystemSharedMemoryStatusRequest() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryStatusRequest& operator=(const SystemSharedMemoryStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryStatusRequest& operator=(SystemSharedMemoryStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryStatusRequest*>(
               &_SystemSharedMemoryStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SystemSharedMemoryStatusRequest& a, SystemSharedMemoryStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryStatusRequest& from) {
    SystemSharedMemoryStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryStatusRequest";
  }
  protected:
  explicit SystemSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse& other);
  static const SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse*>(&_SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.SystemSharedMemoryStatusResponse.RegionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class SystemSharedMemoryStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryStatusResponse) */ {
 public:
  inline SystemSharedMemoryStatusResponse() : SystemSharedMemoryStatusResponse(nullptr) {}
  ~SystemSharedMemoryStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryStatusResponse(const SystemSharedMemoryStatusResponse& from);
  SystemSharedMemoryStatusResponse(SystemSharedMemoryStatusResponse&& from) noexcept
    : SystemSharedMemoryStatusResponse() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryStatusResponse& operator=(const SystemSharedMemoryStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryStatusResponse& operator=(SystemSharedMemoryStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryStatusResponse* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryStatusResponse*>(
               &_SystemSharedMemoryStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SystemSharedMemoryStatusResponse& a, SystemSharedMemoryStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryStatusResponse& from) {
    SystemSharedMemoryStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryStatusResponse";
  }
  protected:
  explicit SystemSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 1,
  };
  // map<string, .inference.SystemSharedMemoryStatusResponse_RegionStatus> regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
      _internal_regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
      _internal_mutable_regions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
      regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
      mutable_regions();

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SystemSharedMemoryStatusResponse_RegionsEntry_DoNotUse,
        std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> regions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryStatusResponse_RegionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryStatusResponse_RegionStatus) */ {
 public:
  inline SystemSharedMemoryStatusResponse_RegionStatus() : SystemSharedMemoryStatusResponse_RegionStatus(nullptr) {}
  ~SystemSharedMemoryStatusResponse_RegionStatus() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryStatusResponse_RegionStatus(const SystemSharedMemoryStatusResponse_RegionStatus& from);
  SystemSharedMemoryStatusResponse_RegionStatus(SystemSharedMemoryStatusResponse_RegionStatus&& from) noexcept
    : SystemSharedMemoryStatusResponse_RegionStatus() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryStatusResponse_RegionStatus& operator=(const SystemSharedMemoryStatusResponse_RegionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryStatusResponse_RegionStatus& operator=(SystemSharedMemoryStatusResponse_RegionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryStatusResponse_RegionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryStatusResponse_RegionStatus* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryStatusResponse_RegionStatus*>(
               &_SystemSharedMemoryStatusResponse_RegionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SystemSharedMemoryStatusResponse_RegionStatus& a, SystemSharedMemoryStatusResponse_RegionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryStatusResponse_RegionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryStatusResponse_RegionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryStatusResponse_RegionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryStatusResponse_RegionStatus& from) {
    SystemSharedMemoryStatusResponse_RegionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryStatusResponse_RegionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryStatusResponse_RegionStatus";
  }
  protected:
  explicit SystemSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kSizeFieldNumber = 3,
    kOffsetFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 size = 3;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint64 offset = 4;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryStatusResponse_RegionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t size_;
    uint64_t offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryRegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryRegisterRequest) */ {
 public:
  inline SystemSharedMemoryRegisterRequest() : SystemSharedMemoryRegisterRequest(nullptr) {}
  ~SystemSharedMemoryRegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryRegisterRequest(const SystemSharedMemoryRegisterRequest& from);
  SystemSharedMemoryRegisterRequest(SystemSharedMemoryRegisterRequest&& from) noexcept
    : SystemSharedMemoryRegisterRequest() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryRegisterRequest& operator=(const SystemSharedMemoryRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryRegisterRequest& operator=(SystemSharedMemoryRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryRegisterRequest*>(
               &_SystemSharedMemoryRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SystemSharedMemoryRegisterRequest& a, SystemSharedMemoryRegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryRegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryRegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryRegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryRegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryRegisterRequest& from) {
    SystemSharedMemoryRegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryRegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryRegisterRequest";
  }
  protected:
  explicit SystemSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kByteSizeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 offset = 3;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 byte_size = 4;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryRegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t offset_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryRegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryRegisterResponse) */ {
 public:
  inline SystemSharedMemoryRegisterResponse() : SystemSharedMemoryRegisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryRegisterResponse(const SystemSharedMemoryRegisterResponse& from);
  SystemSharedMemoryRegisterResponse(SystemSharedMemoryRegisterResponse&& from) noexcept
    : SystemSharedMemoryRegisterResponse() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryRegisterResponse& operator=(const SystemSharedMemoryRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryRegisterResponse& operator=(SystemSharedMemoryRegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryRegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryRegisterResponse* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryRegisterResponse*>(
               &_SystemSharedMemoryRegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SystemSharedMemoryRegisterResponse& a, SystemSharedMemoryRegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryRegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryRegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryRegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryRegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SystemSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SystemSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryRegisterResponse";
  }
  protected:
  explicit SystemSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryRegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryUnregisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryUnregisterRequest) */ {
 public:
  inline SystemSharedMemoryUnregisterRequest() : SystemSharedMemoryUnregisterRequest(nullptr) {}
  ~SystemSharedMemoryUnregisterRequest() override;
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryUnregisterRequest(const SystemSharedMemoryUnregisterRequest& from);
  SystemSharedMemoryUnregisterRequest(SystemSharedMemoryUnregisterRequest&& from) noexcept
    : SystemSharedMemoryUnregisterRequest() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryUnregisterRequest& operator=(const SystemSharedMemoryUnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryUnregisterRequest& operator=(SystemSharedMemoryUnregisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryUnregisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryUnregisterRequest* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryUnregisterRequest*>(
               &_SystemSharedMemoryUnregisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SystemSharedMemoryUnregisterRequest& a, SystemSharedMemoryUnregisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryUnregisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryUnregisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSharedMemoryUnregisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemSharedMemoryUnregisterRequest& from) {
    SystemSharedMemoryUnregisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSharedMemoryUnregisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryUnregisterRequest";
  }
  protected:
  explicit SystemSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryUnregisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SystemSharedMemoryUnregisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.SystemSharedMemoryUnregisterResponse) */ {
 public:
  inline SystemSharedMemoryUnregisterResponse() : SystemSharedMemoryUnregisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SystemSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSharedMemoryUnregisterResponse(const SystemSharedMemoryUnregisterResponse& from);
  SystemSharedMemoryUnregisterResponse(SystemSharedMemoryUnregisterResponse&& from) noexcept
    : SystemSharedMemoryUnregisterResponse() {
    *this = ::std::move(from);
  }

  inline SystemSharedMemoryUnregisterResponse& operator=(const SystemSharedMemoryUnregisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSharedMemoryUnregisterResponse& operator=(SystemSharedMemoryUnregisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSharedMemoryUnregisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSharedMemoryUnregisterResponse* internal_default_instance() {
    return reinterpret_cast<const SystemSharedMemoryUnregisterResponse*>(
               &_SystemSharedMemoryUnregisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SystemSharedMemoryUnregisterResponse& a, SystemSharedMemoryUnregisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSharedMemoryUnregisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSharedMemoryUnregisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SystemSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SystemSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.SystemSharedMemoryUnregisterResponse";
  }
  protected:
  explicit SystemSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.SystemSharedMemoryUnregisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryStatusRequest) */ {
 public:
  inline CudaSharedMemoryStatusRequest() : CudaSharedMemoryStatusRequest(nullptr) {}
  ~CudaSharedMemoryStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryStatusRequest(const CudaSharedMemoryStatusRequest& from);
  CudaSharedMemoryStatusRequest(CudaSharedMemoryStatusRequest&& from) noexcept
    : CudaSharedMemoryStatusRequest() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryStatusRequest& operator=(const CudaSharedMemoryStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryStatusRequest& operator=(CudaSharedMemoryStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryStatusRequest* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryStatusRequest*>(
               &_CudaSharedMemoryStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CudaSharedMemoryStatusRequest& a, CudaSharedMemoryStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryStatusRequest& from) {
    CudaSharedMemoryStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryStatusRequest";
  }
  protected:
  explicit CudaSharedMemoryStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse, 
    std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse& other);
  static const CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse*>(&_CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.CudaSharedMemoryStatusResponse.RegionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class CudaSharedMemoryStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryStatusResponse) */ {
 public:
  inline CudaSharedMemoryStatusResponse() : CudaSharedMemoryStatusResponse(nullptr) {}
  ~CudaSharedMemoryStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryStatusResponse(const CudaSharedMemoryStatusResponse& from);
  CudaSharedMemoryStatusResponse(CudaSharedMemoryStatusResponse&& from) noexcept
    : CudaSharedMemoryStatusResponse() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryStatusResponse& operator=(const CudaSharedMemoryStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryStatusResponse& operator=(CudaSharedMemoryStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryStatusResponse* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryStatusResponse*>(
               &_CudaSharedMemoryStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CudaSharedMemoryStatusResponse& a, CudaSharedMemoryStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryStatusResponse& from) {
    CudaSharedMemoryStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryStatusResponse";
  }
  protected:
  explicit CudaSharedMemoryStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 1,
  };
  // map<string, .inference.CudaSharedMemoryStatusResponse_RegionStatus> regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
      _internal_regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
      _internal_mutable_regions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
      regions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
      mutable_regions();

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CudaSharedMemoryStatusResponse_RegionsEntry_DoNotUse,
        std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> regions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryStatusResponse_RegionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryStatusResponse_RegionStatus) */ {
 public:
  inline CudaSharedMemoryStatusResponse_RegionStatus() : CudaSharedMemoryStatusResponse_RegionStatus(nullptr) {}
  ~CudaSharedMemoryStatusResponse_RegionStatus() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryStatusResponse_RegionStatus(const CudaSharedMemoryStatusResponse_RegionStatus& from);
  CudaSharedMemoryStatusResponse_RegionStatus(CudaSharedMemoryStatusResponse_RegionStatus&& from) noexcept
    : CudaSharedMemoryStatusResponse_RegionStatus() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryStatusResponse_RegionStatus& operator=(const CudaSharedMemoryStatusResponse_RegionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryStatusResponse_RegionStatus& operator=(CudaSharedMemoryStatusResponse_RegionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryStatusResponse_RegionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryStatusResponse_RegionStatus* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryStatusResponse_RegionStatus*>(
               &_CudaSharedMemoryStatusResponse_RegionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CudaSharedMemoryStatusResponse_RegionStatus& a, CudaSharedMemoryStatusResponse_RegionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryStatusResponse_RegionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryStatusResponse_RegionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryStatusResponse_RegionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryStatusResponse_RegionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryStatusResponse_RegionStatus& from) {
    CudaSharedMemoryStatusResponse_RegionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryStatusResponse_RegionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryStatusResponse_RegionStatus";
  }
  protected:
  explicit CudaSharedMemoryStatusResponse_RegionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCudaIpcHandleFieldNumber = 3,
    kDeviceIdFieldNumber = 2,
    kByteSizeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes cuda_ipc_handle = 3;
  void clear_cuda_ipc_handle();
  const std::string& cuda_ipc_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cuda_ipc_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cuda_ipc_handle();
  PROTOBUF_NODISCARD std::string* release_cuda_ipc_handle();
  void set_allocated_cuda_ipc_handle(std::string* cuda_ipc_handle);
  private:
  const std::string& _internal_cuda_ipc_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cuda_ipc_handle(const std::string& value);
  std::string* _internal_mutable_cuda_ipc_handle();
  public:

  // int64 device_id = 2;
  void clear_device_id();
  int64_t device_id() const;
  void set_device_id(int64_t value);
  private:
  int64_t _internal_device_id() const;
  void _internal_set_device_id(int64_t value);
  public:

  // uint64 byte_size = 4;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryStatusResponse_RegionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cuda_ipc_handle_;
    int64_t device_id_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryRegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryRegisterRequest) */ {
 public:
  inline CudaSharedMemoryRegisterRequest() : CudaSharedMemoryRegisterRequest(nullptr) {}
  ~CudaSharedMemoryRegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryRegisterRequest(const CudaSharedMemoryRegisterRequest& from);
  CudaSharedMemoryRegisterRequest(CudaSharedMemoryRegisterRequest&& from) noexcept
    : CudaSharedMemoryRegisterRequest() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryRegisterRequest& operator=(const CudaSharedMemoryRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryRegisterRequest& operator=(CudaSharedMemoryRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryRegisterRequest*>(
               &_CudaSharedMemoryRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CudaSharedMemoryRegisterRequest& a, CudaSharedMemoryRegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryRegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryRegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryRegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryRegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryRegisterRequest& from) {
    CudaSharedMemoryRegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryRegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryRegisterRequest";
  }
  protected:
  explicit CudaSharedMemoryRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRawHandleFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kByteSizeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes raw_handle = 2;
  void clear_raw_handle();
  const std::string& raw_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_handle();
  PROTOBUF_NODISCARD std::string* release_raw_handle();
  void set_allocated_raw_handle(std::string* raw_handle);
  private:
  const std::string& _internal_raw_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_handle(const std::string& value);
  std::string* _internal_mutable_raw_handle();
  public:

  // int64 device_id = 3;
  void clear_device_id();
  int64_t device_id() const;
  void set_device_id(int64_t value);
  private:
  int64_t _internal_device_id() const;
  void _internal_set_device_id(int64_t value);
  public:

  // uint64 byte_size = 4;
  void clear_byte_size();
  uint64_t byte_size() const;
  void set_byte_size(uint64_t value);
  private:
  uint64_t _internal_byte_size() const;
  void _internal_set_byte_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryRegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_handle_;
    int64_t device_id_;
    uint64_t byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryRegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryRegisterResponse) */ {
 public:
  inline CudaSharedMemoryRegisterResponse() : CudaSharedMemoryRegisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryRegisterResponse(const CudaSharedMemoryRegisterResponse& from);
  CudaSharedMemoryRegisterResponse(CudaSharedMemoryRegisterResponse&& from) noexcept
    : CudaSharedMemoryRegisterResponse() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryRegisterResponse& operator=(const CudaSharedMemoryRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryRegisterResponse& operator=(CudaSharedMemoryRegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryRegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryRegisterResponse* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryRegisterResponse*>(
               &_CudaSharedMemoryRegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CudaSharedMemoryRegisterResponse& a, CudaSharedMemoryRegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryRegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryRegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryRegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryRegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CudaSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CudaSharedMemoryRegisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryRegisterResponse";
  }
  protected:
  explicit CudaSharedMemoryRegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryRegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryUnregisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryUnregisterRequest) */ {
 public:
  inline CudaSharedMemoryUnregisterRequest() : CudaSharedMemoryUnregisterRequest(nullptr) {}
  ~CudaSharedMemoryUnregisterRequest() override;
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryUnregisterRequest(const CudaSharedMemoryUnregisterRequest& from);
  CudaSharedMemoryUnregisterRequest(CudaSharedMemoryUnregisterRequest&& from) noexcept
    : CudaSharedMemoryUnregisterRequest() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryUnregisterRequest& operator=(const CudaSharedMemoryUnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryUnregisterRequest& operator=(CudaSharedMemoryUnregisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryUnregisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryUnregisterRequest* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryUnregisterRequest*>(
               &_CudaSharedMemoryUnregisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CudaSharedMemoryUnregisterRequest& a, CudaSharedMemoryUnregisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryUnregisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryUnregisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryUnregisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CudaSharedMemoryUnregisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CudaSharedMemoryUnregisterRequest& from) {
    CudaSharedMemoryUnregisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CudaSharedMemoryUnregisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryUnregisterRequest";
  }
  protected:
  explicit CudaSharedMemoryUnregisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryUnregisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CudaSharedMemoryUnregisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:inference.CudaSharedMemoryUnregisterResponse) */ {
 public:
  inline CudaSharedMemoryUnregisterResponse() : CudaSharedMemoryUnregisterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CudaSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CudaSharedMemoryUnregisterResponse(const CudaSharedMemoryUnregisterResponse& from);
  CudaSharedMemoryUnregisterResponse(CudaSharedMemoryUnregisterResponse&& from) noexcept
    : CudaSharedMemoryUnregisterResponse() {
    *this = ::std::move(from);
  }

  inline CudaSharedMemoryUnregisterResponse& operator=(const CudaSharedMemoryUnregisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CudaSharedMemoryUnregisterResponse& operator=(CudaSharedMemoryUnregisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CudaSharedMemoryUnregisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CudaSharedMemoryUnregisterResponse* internal_default_instance() {
    return reinterpret_cast<const CudaSharedMemoryUnregisterResponse*>(
               &_CudaSharedMemoryUnregisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CudaSharedMemoryUnregisterResponse& a, CudaSharedMemoryUnregisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CudaSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CudaSharedMemoryUnregisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CudaSharedMemoryUnregisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CudaSharedMemoryUnregisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CudaSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CudaSharedMemoryUnregisterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.CudaSharedMemoryUnregisterResponse";
  }
  protected:
  explicit CudaSharedMemoryUnregisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.CudaSharedMemoryUnregisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInferRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelInferRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelInferRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelInferRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelInferRequest_ParametersEntry_DoNotUse& other);
  static const ModelInferRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelInferRequest_ParametersEntry_DoNotUse*>(&_ModelInferRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelInferRequest.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelInferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInferRequest) */ {
 public:
  inline ModelInferRequest() : ModelInferRequest(nullptr) {}
  ~ModelInferRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelInferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInferRequest(const ModelInferRequest& from);
  ModelInferRequest(ModelInferRequest&& from) noexcept
    : ModelInferRequest() {
    *this = ::std::move(from);
  }

  inline ModelInferRequest& operator=(const ModelInferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInferRequest& operator=(ModelInferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInferRequest* internal_default_instance() {
    return reinterpret_cast<const ModelInferRequest*>(
               &_ModelInferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ModelInferRequest& a, ModelInferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInferRequest& from) {
    ModelInferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInferRequest";
  }
  protected:
  explicit ModelInferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kInputsFieldNumber = 5,
    kOutputsFieldNumber = 6,
    kRawInputContentsFieldNumber = 7,
    kModelNameFieldNumber = 1,
    kModelVersionFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // repeated .inference.InferInputTensor inputs = 5;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::inference::InferInputTensor* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >*
      mutable_inputs();
  private:
  const ::inference::InferInputTensor& _internal_inputs(int index) const;
  ::inference::InferInputTensor* _internal_add_inputs();
  public:
  const ::inference::InferInputTensor& inputs(int index) const;
  ::inference::InferInputTensor* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >&
      inputs() const;

  // repeated .inference.InferRequestedOutputTensor outputs = 6;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::InferRequestedOutputTensor* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >*
      mutable_outputs();
  private:
  const ::inference::InferRequestedOutputTensor& _internal_outputs(int index) const;
  ::inference::InferRequestedOutputTensor* _internal_add_outputs();
  public:
  const ::inference::InferRequestedOutputTensor& outputs(int index) const;
  ::inference::InferRequestedOutputTensor* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >&
      outputs() const;

  // repeated bytes raw_input_contents = 7;
  int raw_input_contents_size() const;
  private:
  int _internal_raw_input_contents_size() const;
  public:
  void clear_raw_input_contents();
  const std::string& raw_input_contents(int index) const;
  std::string* mutable_raw_input_contents(int index);
  void set_raw_input_contents(int index, const std::string& value);
  void set_raw_input_contents(int index, std::string&& value);
  void set_raw_input_contents(int index, const char* value);
  void set_raw_input_contents(int index, const void* value, size_t size);
  std::string* add_raw_input_contents();
  void add_raw_input_contents(const std::string& value);
  void add_raw_input_contents(std::string&& value);
  void add_raw_input_contents(const char* value);
  void add_raw_input_contents(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& raw_input_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_raw_input_contents();
  private:
  const std::string& _internal_raw_input_contents(int index) const;
  std::string* _internal_add_raw_input_contents();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 2;
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelInferRequest_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> raw_input_contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInferResponse_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferResponse_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelInferResponse_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelInferResponse_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelInferResponse_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelInferResponse_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelInferResponse_ParametersEntry_DoNotUse& other);
  static const ModelInferResponse_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelInferResponse_ParametersEntry_DoNotUse*>(&_ModelInferResponse_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelInferResponse.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelInferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInferResponse) */ {
 public:
  inline ModelInferResponse() : ModelInferResponse(nullptr) {}
  ~ModelInferResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelInferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInferResponse(const ModelInferResponse& from);
  ModelInferResponse(ModelInferResponse&& from) noexcept
    : ModelInferResponse() {
    *this = ::std::move(from);
  }

  inline ModelInferResponse& operator=(const ModelInferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInferResponse& operator=(ModelInferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInferResponse* internal_default_instance() {
    return reinterpret_cast<const ModelInferResponse*>(
               &_ModelInferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ModelInferResponse& a, ModelInferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInferResponse& from) {
    ModelInferResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInferResponse";
  }
  protected:
  explicit ModelInferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kOutputsFieldNumber = 5,
    kRawOutputContentsFieldNumber = 6,
    kModelNameFieldNumber = 1,
    kModelVersionFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // repeated .inference.InferOutputTensor outputs = 5;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::InferOutputTensor* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >*
      mutable_outputs();
  private:
  const ::inference::InferOutputTensor& _internal_outputs(int index) const;
  ::inference::InferOutputTensor* _internal_add_outputs();
  public:
  const ::inference::InferOutputTensor& outputs(int index) const;
  ::inference::InferOutputTensor* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >&
      outputs() const;

  // repeated bytes raw_output_contents = 6;
  int raw_output_contents_size() const;
  private:
  int _internal_raw_output_contents_size() const;
  public:
  void clear_raw_output_contents();
  const std::string& raw_output_contents(int index) const;
  std::string* mutable_raw_output_contents(int index);
  void set_raw_output_contents(int index, const std::string& value);
  void set_raw_output_contents(int index, std::string&& value);
  void set_raw_output_contents(int index, const char* value);
  void set_raw_output_contents(int index, const void* value, size_t size);
  std::string* add_raw_output_contents();
  void add_raw_output_contents(const std::string& value);
  void add_raw_output_contents(std::string&& value);
  void add_raw_output_contents(const char* value);
  void add_raw_output_contents(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& raw_output_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_raw_output_contents();
  private:
  const std::string& _internal_raw_output_contents(int index) const;
  std::string* _internal_add_raw_output_contents();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 2;
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelInferResponse_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> raw_output_contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStreamInferRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelStreamInferRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelStreamInferRequest_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelStreamInferRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelStreamInferRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelStreamInferRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelStreamInferRequest_ParametersEntry_DoNotUse& other);
  static const ModelStreamInferRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelStreamInferRequest_ParametersEntry_DoNotUse*>(&_ModelStreamInferRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelStreamInferRequest.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelStreamInferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStreamInferRequest) */ {
 public:
  inline ModelStreamInferRequest() : ModelStreamInferRequest(nullptr) {}
  ~ModelStreamInferRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelStreamInferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStreamInferRequest(const ModelStreamInferRequest& from);
  ModelStreamInferRequest(ModelStreamInferRequest&& from) noexcept
    : ModelStreamInferRequest() {
    *this = ::std::move(from);
  }

  inline ModelStreamInferRequest& operator=(const ModelStreamInferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStreamInferRequest& operator=(ModelStreamInferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStreamInferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStreamInferRequest* internal_default_instance() {
    return reinterpret_cast<const ModelStreamInferRequest*>(
               &_ModelStreamInferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ModelStreamInferRequest& a, ModelStreamInferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStreamInferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStreamInferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStreamInferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStreamInferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStreamInferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStreamInferRequest& from) {
    ModelStreamInferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStreamInferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStreamInferRequest";
  }
  protected:
  explicit ModelStreamInferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kInputsFieldNumber = 5,
    kOutputsFieldNumber = 6,
    kRawInputContentsFieldNumber = 7,
    kModelNameFieldNumber = 1,
    kModelVersionFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // repeated .inference.InferInputTensor inputs = 5;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::inference::InferInputTensor* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >*
      mutable_inputs();
  private:
  const ::inference::InferInputTensor& _internal_inputs(int index) const;
  ::inference::InferInputTensor* _internal_add_inputs();
  public:
  const ::inference::InferInputTensor& inputs(int index) const;
  ::inference::InferInputTensor* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >&
      inputs() const;

  // repeated .inference.InferRequestedOutputTensor outputs = 6;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::InferRequestedOutputTensor* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >*
      mutable_outputs();
  private:
  const ::inference::InferRequestedOutputTensor& _internal_outputs(int index) const;
  ::inference::InferRequestedOutputTensor* _internal_add_outputs();
  public:
  const ::inference::InferRequestedOutputTensor& outputs(int index) const;
  ::inference::InferRequestedOutputTensor* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >&
      outputs() const;

  // repeated bytes raw_input_contents = 7;
  int raw_input_contents_size() const;
  private:
  int _internal_raw_input_contents_size() const;
  public:
  void clear_raw_input_contents();
  const std::string& raw_input_contents(int index) const;
  std::string* mutable_raw_input_contents(int index);
  void set_raw_input_contents(int index, const std::string& value);
  void set_raw_input_contents(int index, std::string&& value);
  void set_raw_input_contents(int index, const char* value);
  void set_raw_input_contents(int index, const void* value, size_t size);
  std::string* add_raw_input_contents();
  void add_raw_input_contents(const std::string& value);
  void add_raw_input_contents(std::string&& value);
  void add_raw_input_contents(const char* value);
  void add_raw_input_contents(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& raw_input_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_raw_input_contents();
  private:
  const std::string& _internal_raw_input_contents(int index) const;
  std::string* _internal_add_raw_input_contents();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 2;
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelStreamInferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelStreamInferRequest_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> raw_input_contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelStreamInferResponse_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelStreamInferResponse_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelStreamInferResponse_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelStreamInferResponse_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelStreamInferResponse_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelStreamInferResponse_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelStreamInferResponse_ParametersEntry_DoNotUse& other);
  static const ModelStreamInferResponse_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelStreamInferResponse_ParametersEntry_DoNotUse*>(&_ModelStreamInferResponse_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelStreamInferResponse.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelStreamInferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelStreamInferResponse) */ {
 public:
  inline ModelStreamInferResponse() : ModelStreamInferResponse(nullptr) {}
  ~ModelStreamInferResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelStreamInferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStreamInferResponse(const ModelStreamInferResponse& from);
  ModelStreamInferResponse(ModelStreamInferResponse&& from) noexcept
    : ModelStreamInferResponse() {
    *this = ::std::move(from);
  }

  inline ModelStreamInferResponse& operator=(const ModelStreamInferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStreamInferResponse& operator=(ModelStreamInferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStreamInferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStreamInferResponse* internal_default_instance() {
    return reinterpret_cast<const ModelStreamInferResponse*>(
               &_ModelStreamInferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ModelStreamInferResponse& a, ModelStreamInferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStreamInferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStreamInferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStreamInferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStreamInferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStreamInferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelStreamInferResponse& from) {
    ModelStreamInferResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStreamInferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelStreamInferResponse";
  }
  protected:
  explicit ModelStreamInferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kOutputsFieldNumber = 5,
    kRawOutputContentsFieldNumber = 6,
    kModelNameFieldNumber = 1,
    kModelVersionFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // repeated .inference.InferOutputTensor outputs = 5;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::inference::InferOutputTensor* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >*
      mutable_outputs();
  private:
  const ::inference::InferOutputTensor& _internal_outputs(int index) const;
  ::inference::InferOutputTensor* _internal_add_outputs();
  public:
  const ::inference::InferOutputTensor& outputs(int index) const;
  ::inference::InferOutputTensor* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >&
      outputs() const;

  // repeated bytes raw_output_contents = 6;
  int raw_output_contents_size() const;
  private:
  int _internal_raw_output_contents_size() const;
  public:
  void clear_raw_output_contents();
  const std::string& raw_output_contents(int index) const;
  std::string* mutable_raw_output_contents(int index);
  void set_raw_output_contents(int index, const std::string& value);
  void set_raw_output_contents(int index, std::string&& value);
  void set_raw_output_contents(int index, const char* value);
  void set_raw_output_contents(int index, const void* value, size_t size);
  std::string* add_raw_output_contents();
  void add_raw_output_contents(const std::string& value);
  void add_raw_output_contents(std::string&& value);
  void add_raw_output_contents(const char* value);
  void add_raw_output_contents(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& raw_output_contents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_raw_output_contents();
  private:
  const std::string& _internal_raw_output_contents(int index) const;
  std::string* _internal_add_raw_output_contents();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 2;
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelStreamInferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelStreamInferResponse_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> raw_output_contents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferInputTensor_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InferInputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InferInputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  InferInputTensor_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InferInputTensor_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InferInputTensor_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InferInputTensor_ParametersEntry_DoNotUse& other);
  static const InferInputTensor_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InferInputTensor_ParametersEntry_DoNotUse*>(&_InferInputTensor_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.InferInputTensor.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class InferInputTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferInputTensor) */ {
 public:
  inline InferInputTensor() : InferInputTensor(nullptr) {}
  ~InferInputTensor() override;
  explicit PROTOBUF_CONSTEXPR InferInputTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferInputTensor(const InferInputTensor& from);
  InferInputTensor(InferInputTensor&& from) noexcept
    : InferInputTensor() {
    *this = ::std::move(from);
  }

  inline InferInputTensor& operator=(const InferInputTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferInputTensor& operator=(InferInputTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferInputTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferInputTensor* internal_default_instance() {
    return reinterpret_cast<const InferInputTensor*>(
               &_InferInputTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(InferInputTensor& a, InferInputTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(InferInputTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferInputTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferInputTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferInputTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferInputTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferInputTensor& from) {
    InferInputTensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferInputTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferInputTensor";
  }
  protected:
  explicit InferInputTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kParametersFieldNumber = 4,
    kNameFieldNumber = 1,
    kDatatypeFieldNumber = 2,
  };
  // repeated int64 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string datatype = 2;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // @@protoc_insertion_point(class_scope:inference.InferInputTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InferInputTensor_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferRequestedOutputTensor_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InferRequestedOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InferRequestedOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  InferRequestedOutputTensor_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InferRequestedOutputTensor_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InferRequestedOutputTensor_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InferRequestedOutputTensor_ParametersEntry_DoNotUse& other);
  static const InferRequestedOutputTensor_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InferRequestedOutputTensor_ParametersEntry_DoNotUse*>(&_InferRequestedOutputTensor_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.InferRequestedOutputTensor.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class InferRequestedOutputTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferRequestedOutputTensor) */ {
 public:
  inline InferRequestedOutputTensor() : InferRequestedOutputTensor(nullptr) {}
  ~InferRequestedOutputTensor() override;
  explicit PROTOBUF_CONSTEXPR InferRequestedOutputTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferRequestedOutputTensor(const InferRequestedOutputTensor& from);
  InferRequestedOutputTensor(InferRequestedOutputTensor&& from) noexcept
    : InferRequestedOutputTensor() {
    *this = ::std::move(from);
  }

  inline InferRequestedOutputTensor& operator=(const InferRequestedOutputTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferRequestedOutputTensor& operator=(InferRequestedOutputTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferRequestedOutputTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferRequestedOutputTensor* internal_default_instance() {
    return reinterpret_cast<const InferRequestedOutputTensor*>(
               &_InferRequestedOutputTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(InferRequestedOutputTensor& a, InferRequestedOutputTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(InferRequestedOutputTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferRequestedOutputTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferRequestedOutputTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferRequestedOutputTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferRequestedOutputTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferRequestedOutputTensor& from) {
    InferRequestedOutputTensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferRequestedOutputTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferRequestedOutputTensor";
  }
  protected:
  explicit InferRequestedOutputTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // map<string, .inference.InferParameter> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.InferRequestedOutputTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InferRequestedOutputTensor_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferOutputTensor_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InferOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InferOutputTensor_ParametersEntry_DoNotUse, 
    std::string, ::inference::InferParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  InferOutputTensor_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InferOutputTensor_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InferOutputTensor_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InferOutputTensor_ParametersEntry_DoNotUse& other);
  static const InferOutputTensor_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InferOutputTensor_ParametersEntry_DoNotUse*>(&_InferOutputTensor_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.InferOutputTensor.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};

// -------------------------------------------------------------------

class InferOutputTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferOutputTensor) */ {
 public:
  inline InferOutputTensor() : InferOutputTensor(nullptr) {}
  ~InferOutputTensor() override;
  explicit PROTOBUF_CONSTEXPR InferOutputTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferOutputTensor(const InferOutputTensor& from);
  InferOutputTensor(InferOutputTensor&& from) noexcept
    : InferOutputTensor() {
    *this = ::std::move(from);
  }

  inline InferOutputTensor& operator=(const InferOutputTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferOutputTensor& operator=(InferOutputTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferOutputTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const InferOutputTensor* internal_default_instance() {
    return reinterpret_cast<const InferOutputTensor*>(
               &_InferOutputTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(InferOutputTensor& a, InferOutputTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(InferOutputTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferOutputTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferOutputTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferOutputTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferOutputTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferOutputTensor& from) {
    InferOutputTensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferOutputTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferOutputTensor";
  }
  protected:
  explicit InferOutputTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kParametersFieldNumber = 4,
    kNameFieldNumber = 1,
    kDatatypeFieldNumber = 2,
  };
  // repeated int64 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // map<string, .inference.InferParameter> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string datatype = 2;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // @@protoc_insertion_point(class_scope:inference.InferOutputTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InferOutputTensor_ParametersEntry_DoNotUse,
        std::string, ::inference::InferParameter,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InferParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.InferParameter) */ {
 public:
  inline InferParameter() : InferParameter(nullptr) {}
  ~InferParameter() override;
  explicit PROTOBUF_CONSTEXPR InferParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InferParameter(const InferParameter& from);
  InferParameter(InferParameter&& from) noexcept
    : InferParameter() {
    *this = ::std::move(from);
  }

  inline InferParameter& operator=(const InferParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferParameter& operator=(InferParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InferParameter& default_instance() {
    return *internal_default_instance();
  }
  enum ParameterChoiceCase {
    kBoolParam = 1,
    kInt64Param = 2,
    kStringParam = 3,
    kDoubleParam = 4,
    PARAMETER_CHOICE_NOT_SET = 0,
  };

  static inline const InferParameter* internal_default_instance() {
    return reinterpret_cast<const InferParameter*>(
               &_InferParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(InferParameter& a, InferParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(InferParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InferParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InferParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InferParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InferParameter& from) {
    InferParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.InferParameter";
  }
  protected:
  explicit InferParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolParamFieldNumber = 1,
    kInt64ParamFieldNumber = 2,
    kStringParamFieldNumber = 3,
    kDoubleParamFieldNumber = 4,
  };
  // bool bool_param = 1;
  bool has_bool_param() const;
  private:
  bool _internal_has_bool_param() const;
  public:
  void clear_bool_param();
  bool bool_param() const;
  void set_bool_param(bool value);
  private:
  bool _internal_bool_param() const;
  void _internal_set_bool_param(bool value);
  public:

  // int64 int64_param = 2;
  bool has_int64_param() const;
  private:
  bool _internal_has_int64_param() const;
  public:
  void clear_int64_param();
  int64_t int64_param() const;
  void set_int64_param(int64_t value);
  private:
  int64_t _internal_int64_param() const;
  void _internal_set_int64_param(int64_t value);
  public:

  // string string_param = 3;
  bool has_string_param() const;
  private:
  bool _internal_has_string_param() const;
  public:
  void clear_string_param();
  const std::string& string_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_param();
  PROTOBUF_NODISCARD std::string* release_string_param();
  void set_allocated_string_param(std::string* string_param);
  private:
  const std::string& _internal_string_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_param(const std::string& value);
  std::string* _internal_mutable_string_param();
  public:

  // double double_param = 4;
  bool has_double_param() const;
  private:
  bool _internal_has_double_param() const;
  public:
  void clear_double_param();
  double double_param() const;
  void set_double_param(double value);
  private:
  double _internal_double_param() const;
  void _internal_set_double_param(double value);
  public:

  void clear_parameter_choice();
  ParameterChoiceCase parameter_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.InferParameter)
 private:
  class _Internal;
  void set_has_bool_param();
  void set_has_int64_param();
  void set_has_string_param();
  void set_has_double_param();

  inline bool has_parameter_choice() const;
  inline void clear_has_parameter_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ParameterChoiceUnion {
      constexpr ParameterChoiceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool bool_param_;
      int64_t int64_param_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_param_;
      double double_param_;
    } parameter_choice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpc_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerLiveRequest

// -------------------------------------------------------------------

// ServerLiveResponse

// bool live = 1;
inline void ServerLiveResponse::clear_live() {
  _impl_.live_ = false;
}
inline bool ServerLiveResponse::_internal_live() const {
  return _impl_.live_;
}
inline bool ServerLiveResponse::live() const {
  // @@protoc_insertion_point(field_get:inference.ServerLiveResponse.live)
  return _internal_live();
}
inline void ServerLiveResponse::_internal_set_live(bool value) {
  
  _impl_.live_ = value;
}
inline void ServerLiveResponse::set_live(bool value) {
  _internal_set_live(value);
  // @@protoc_insertion_point(field_set:inference.ServerLiveResponse.live)
}

// -------------------------------------------------------------------

// ServerReadyRequest

// -------------------------------------------------------------------

// ServerReadyResponse

// bool ready = 1;
inline void ServerReadyResponse::clear_ready() {
  _impl_.ready_ = false;
}
inline bool ServerReadyResponse::_internal_ready() const {
  return _impl_.ready_;
}
inline bool ServerReadyResponse::ready() const {
  // @@protoc_insertion_point(field_get:inference.ServerReadyResponse.ready)
  return _internal_ready();
}
inline void ServerReadyResponse::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void ServerReadyResponse::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:inference.ServerReadyResponse.ready)
}

// -------------------------------------------------------------------

// ModelReadyRequest

// string name = 1;
inline void ModelReadyRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelReadyRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelReadyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReadyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelReadyRequest.name)
}
inline std::string* ModelReadyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelReadyRequest.name)
  return _s;
}
inline const std::string& ModelReadyRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelReadyRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelReadyRequest.name)
  return _impl_.name_.Release();
}
inline void ModelReadyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelReadyRequest.name)
}

// string version = 2;
inline void ModelReadyRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelReadyRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelReadyRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReadyRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelReadyRequest.version)
}
inline std::string* ModelReadyRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelReadyRequest.version)
  return _s;
}
inline const std::string& ModelReadyRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelReadyRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReadyRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelReadyRequest.version)
  return _impl_.version_.Release();
}
inline void ModelReadyRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelReadyRequest.version)
}

// -------------------------------------------------------------------

// ModelReadyResponse

// bool ready = 1;
inline void ModelReadyResponse::clear_ready() {
  _impl_.ready_ = false;
}
inline bool ModelReadyResponse::_internal_ready() const {
  return _impl_.ready_;
}
inline bool ModelReadyResponse::ready() const {
  // @@protoc_insertion_point(field_get:inference.ModelReadyResponse.ready)
  return _internal_ready();
}
inline void ModelReadyResponse::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void ModelReadyResponse::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:inference.ModelReadyResponse.ready)
}

// -------------------------------------------------------------------

// ServerMetadataRequest

// -------------------------------------------------------------------

// ServerMetadataResponse

// string name = 1;
inline void ServerMetadataResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServerMetadataResponse::name() const {
  // @@protoc_insertion_point(field_get:inference.ServerMetadataResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerMetadataResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.name)
}
inline std::string* ServerMetadataResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ServerMetadataResponse.name)
  return _s;
}
inline const std::string& ServerMetadataResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ServerMetadataResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::release_name() {
  // @@protoc_insertion_point(field_release:inference.ServerMetadataResponse.name)
  return _impl_.name_.Release();
}
inline void ServerMetadataResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ServerMetadataResponse.name)
}

// string version = 2;
inline void ServerMetadataResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ServerMetadataResponse::version() const {
  // @@protoc_insertion_point(field_get:inference.ServerMetadataResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerMetadataResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.version)
}
inline std::string* ServerMetadataResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ServerMetadataResponse.version)
  return _s;
}
inline const std::string& ServerMetadataResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ServerMetadataResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerMetadataResponse::release_version() {
  // @@protoc_insertion_point(field_release:inference.ServerMetadataResponse.version)
  return _impl_.version_.Release();
}
inline void ServerMetadataResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ServerMetadataResponse.version)
}

// repeated string extensions = 3;
inline int ServerMetadataResponse::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int ServerMetadataResponse::extensions_size() const {
  return _internal_extensions_size();
}
inline void ServerMetadataResponse::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline std::string* ServerMetadataResponse::add_extensions() {
  std::string* _s = _internal_add_extensions();
  // @@protoc_insertion_point(field_add_mutable:inference.ServerMetadataResponse.extensions)
  return _s;
}
inline const std::string& ServerMetadataResponse::_internal_extensions(int index) const {
  return _impl_.extensions_.Get(index);
}
inline const std::string& ServerMetadataResponse::extensions(int index) const {
  // @@protoc_insertion_point(field_get:inference.ServerMetadataResponse.extensions)
  return _internal_extensions(index);
}
inline std::string* ServerMetadataResponse::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ServerMetadataResponse.extensions)
  return _impl_.extensions_.Mutable(index);
}
inline void ServerMetadataResponse::set_extensions(int index, const std::string& value) {
  _impl_.extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::set_extensions(int index, std::string&& value) {
  _impl_.extensions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::set_extensions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::set_extensions(int index, const char* value, size_t size) {
  _impl_.extensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ServerMetadataResponse.extensions)
}
inline std::string* ServerMetadataResponse::_internal_add_extensions() {
  return _impl_.extensions_.Add();
}
inline void ServerMetadataResponse::add_extensions(const std::string& value) {
  _impl_.extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::add_extensions(std::string&& value) {
  _impl_.extensions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::add_extensions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ServerMetadataResponse.extensions)
}
inline void ServerMetadataResponse::add_extensions(const char* value, size_t size) {
  _impl_.extensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ServerMetadataResponse.extensions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerMetadataResponse::extensions() const {
  // @@protoc_insertion_point(field_list:inference.ServerMetadataResponse.extensions)
  return _impl_.extensions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServerMetadataResponse::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:inference.ServerMetadataResponse.extensions)
  return &_impl_.extensions_;
}

// -------------------------------------------------------------------

// ModelMetadataRequest

// string name = 1;
inline void ModelMetadataRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelMetadataRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataRequest.name)
}
inline std::string* ModelMetadataRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataRequest.name)
  return _s;
}
inline const std::string& ModelMetadataRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelMetadataRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataRequest.name)
  return _impl_.name_.Release();
}
inline void ModelMetadataRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataRequest.name)
}

// string version = 2;
inline void ModelMetadataRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelMetadataRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataRequest.version)
}
inline std::string* ModelMetadataRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataRequest.version)
  return _s;
}
inline const std::string& ModelMetadataRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelMetadataRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataRequest.version)
  return _impl_.version_.Release();
}
inline void ModelMetadataRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataRequest.version)
}

// -------------------------------------------------------------------

// ModelMetadataResponse

// string name = 1;
inline void ModelMetadataResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.name)
}
inline std::string* ModelMetadataResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.name)
  return _s;
}
inline const std::string& ModelMetadataResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelMetadataResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse.name)
  return _impl_.name_.Release();
}
inline void ModelMetadataResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse.name)
}

// repeated string versions = 2;
inline int ModelMetadataResponse::_internal_versions_size() const {
  return _impl_.versions_.size();
}
inline int ModelMetadataResponse::versions_size() const {
  return _internal_versions_size();
}
inline void ModelMetadataResponse::clear_versions() {
  _impl_.versions_.Clear();
}
inline std::string* ModelMetadataResponse::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelMetadataResponse.versions)
  return _s;
}
inline const std::string& ModelMetadataResponse::_internal_versions(int index) const {
  return _impl_.versions_.Get(index);
}
inline const std::string& ModelMetadataResponse::versions(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.versions)
  return _internal_versions(index);
}
inline std::string* ModelMetadataResponse::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.versions)
  return _impl_.versions_.Mutable(index);
}
inline void ModelMetadataResponse::set_versions(int index, const std::string& value) {
  _impl_.versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::set_versions(int index, std::string&& value) {
  _impl_.versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::set_versions(int index, const char* value, size_t size) {
  _impl_.versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelMetadataResponse.versions)
}
inline std::string* ModelMetadataResponse::_internal_add_versions() {
  return _impl_.versions_.Add();
}
inline void ModelMetadataResponse::add_versions(const std::string& value) {
  _impl_.versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::add_versions(std::string&& value) {
  _impl_.versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelMetadataResponse.versions)
}
inline void ModelMetadataResponse::add_versions(const char* value, size_t size) {
  _impl_.versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelMetadataResponse.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelMetadataResponse::versions() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse.versions)
  return _impl_.versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelMetadataResponse::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse.versions)
  return &_impl_.versions_;
}

// string platform = 3;
inline void ModelMetadataResponse::clear_platform() {
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse::platform() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse::set_platform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse.platform)
}
inline std::string* ModelMetadataResponse::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.platform)
  return _s;
}
inline const std::string& ModelMetadataResponse::_internal_platform() const {
  return _impl_.platform_.Get();
}
inline void ModelMetadataResponse::_internal_set_platform(const std::string& value) {
  
  _impl_.platform_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::_internal_mutable_platform() {
  
  return _impl_.platform_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse::release_platform() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse.platform)
  return _impl_.platform_.Release();
}
inline void ModelMetadataResponse::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  _impl_.platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.platform_.IsDefault()) {
    _impl_.platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse.platform)
}

// repeated .inference.ModelMetadataResponse_TensorMetadata inputs = 4;
inline int ModelMetadataResponse::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int ModelMetadataResponse::inputs_size() const {
  return _internal_inputs_size();
}
inline void ModelMetadataResponse::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
ModelMetadataResponse::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse.inputs)
  return &_impl_.inputs_;
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::inputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.inputs)
  return _internal_inputs(index);
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::add_inputs() {
  ::inference::ModelMetadataResponse_TensorMetadata* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
ModelMetadataResponse::inputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse.inputs)
  return _impl_.inputs_;
}

// repeated .inference.ModelMetadataResponse_TensorMetadata outputs = 5;
inline int ModelMetadataResponse::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelMetadataResponse::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelMetadataResponse::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >*
ModelMetadataResponse::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::ModelMetadataResponse_TensorMetadata& ModelMetadataResponse::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse.outputs)
  return _internal_outputs(index);
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::ModelMetadataResponse_TensorMetadata* ModelMetadataResponse::add_outputs() {
  ::inference::ModelMetadataResponse_TensorMetadata* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelMetadataResponse_TensorMetadata >&
ModelMetadataResponse::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse.outputs)
  return _impl_.outputs_;
}

// -------------------------------------------------------------------

// ModelMetadataResponse_TensorMetadata

// string name = 1;
inline void ModelMetadataResponse_TensorMetadata::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse_TensorMetadata::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse_TensorMetadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse_TensorMetadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse_TensorMetadata.name)
}
inline std::string* ModelMetadataResponse_TensorMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse_TensorMetadata.name)
  return _s;
}
inline const std::string& ModelMetadataResponse_TensorMetadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelMetadataResponse_TensorMetadata::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse_TensorMetadata.name)
  return _impl_.name_.Release();
}
inline void ModelMetadataResponse_TensorMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse_TensorMetadata.name)
}

// string datatype = 2;
inline void ModelMetadataResponse_TensorMetadata::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& ModelMetadataResponse_TensorMetadata::datatype() const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse_TensorMetadata.datatype)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetadataResponse_TensorMetadata::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse_TensorMetadata.datatype)
}
inline std::string* ModelMetadataResponse_TensorMetadata::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:inference.ModelMetadataResponse_TensorMetadata.datatype)
  return _s;
}
inline const std::string& ModelMetadataResponse_TensorMetadata::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void ModelMetadataResponse_TensorMetadata::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetadataResponse_TensorMetadata::release_datatype() {
  // @@protoc_insertion_point(field_release:inference.ModelMetadataResponse_TensorMetadata.datatype)
  return _impl_.datatype_.Release();
}
inline void ModelMetadataResponse_TensorMetadata::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelMetadataResponse_TensorMetadata.datatype)
}

// repeated int64 shape = 3;
inline int ModelMetadataResponse_TensorMetadata::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int ModelMetadataResponse_TensorMetadata::shape_size() const {
  return _internal_shape_size();
}
inline void ModelMetadataResponse_TensorMetadata::clear_shape() {
  _impl_.shape_.Clear();
}
inline int64_t ModelMetadataResponse_TensorMetadata::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int64_t ModelMetadataResponse_TensorMetadata::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelMetadataResponse_TensorMetadata.shape)
  return _internal_shape(index);
}
inline void ModelMetadataResponse_TensorMetadata::set_shape(int index, int64_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelMetadataResponse_TensorMetadata.shape)
}
inline void ModelMetadataResponse_TensorMetadata::_internal_add_shape(int64_t value) {
  _impl_.shape_.Add(value);
}
inline void ModelMetadataResponse_TensorMetadata::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.ModelMetadataResponse_TensorMetadata.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelMetadataResponse_TensorMetadata::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ModelMetadataResponse_TensorMetadata::shape() const {
  // @@protoc_insertion_point(field_list:inference.ModelMetadataResponse_TensorMetadata.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelMetadataResponse_TensorMetadata::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ModelMetadataResponse_TensorMetadata::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelMetadataResponse_TensorMetadata.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// ModelConfigRequest

// string name = 1;
inline void ModelConfigRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelConfigRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfigRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfigRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfigRequest.name)
}
inline std::string* ModelConfigRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfigRequest.name)
  return _s;
}
inline const std::string& ModelConfigRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelConfigRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelConfigRequest.name)
  return _impl_.name_.Release();
}
inline void ModelConfigRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfigRequest.name)
}

// string version = 2;
inline void ModelConfigRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelConfigRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfigRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfigRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfigRequest.version)
}
inline std::string* ModelConfigRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfigRequest.version)
  return _s;
}
inline const std::string& ModelConfigRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelConfigRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfigRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelConfigRequest.version)
  return _impl_.version_.Release();
}
inline void ModelConfigRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfigRequest.version)
}

// -------------------------------------------------------------------

// ModelConfigResponse

// string config = 1;
inline void ModelConfigResponse::clear_config() {
  _impl_.config_.ClearToEmpty();
}
inline const std::string& ModelConfigResponse::config() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfigResponse.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelConfigResponse::set_config(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelConfigResponse.config)
}
inline std::string* ModelConfigResponse::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:inference.ModelConfigResponse.config)
  return _s;
}
inline const std::string& ModelConfigResponse::_internal_config() const {
  return _impl_.config_.Get();
}
inline void ModelConfigResponse::_internal_set_config(const std::string& value) {
  
  _impl_.config_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelConfigResponse::_internal_mutable_config() {
  
  return _impl_.config_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelConfigResponse::release_config() {
  // @@protoc_insertion_point(field_release:inference.ModelConfigResponse.config)
  return _impl_.config_.Release();
}
inline void ModelConfigResponse::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    
  } else {
    
  }
  _impl_.config_.SetAllocated(config, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_.IsDefault()) {
    _impl_.config_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfigResponse.config)
}

// -------------------------------------------------------------------

// ModelStatisticsRequest

// string name = 1;
inline void ModelStatisticsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelStatisticsRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatisticsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatisticsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatisticsRequest.name)
}
inline std::string* ModelStatisticsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatisticsRequest.name)
  return _s;
}
inline const std::string& ModelStatisticsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelStatisticsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelStatisticsRequest.name)
  return _impl_.name_.Release();
}
inline void ModelStatisticsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatisticsRequest.name)
}

// string version = 2;
inline void ModelStatisticsRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelStatisticsRequest::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatisticsRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatisticsRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatisticsRequest.version)
}
inline std::string* ModelStatisticsRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatisticsRequest.version)
  return _s;
}
inline const std::string& ModelStatisticsRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelStatisticsRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatisticsRequest::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelStatisticsRequest.version)
  return _impl_.version_.Release();
}
inline void ModelStatisticsRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatisticsRequest.version)
}

// -------------------------------------------------------------------

// ModelStatisticsResponse

// repeated .inference.ModelStatistics model_stats = 1;
inline int ModelStatisticsResponse::_internal_model_stats_size() const {
  return _impl_.model_stats_.size();
}
inline int ModelStatisticsResponse::model_stats_size() const {
  return _internal_model_stats_size();
}
inline void ModelStatisticsResponse::clear_model_stats() {
  _impl_.model_stats_.Clear();
}
inline ::inference::ModelStatistics* ModelStatisticsResponse::mutable_model_stats(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStatisticsResponse.model_stats)
  return _impl_.model_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >*
ModelStatisticsResponse::mutable_model_stats() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStatisticsResponse.model_stats)
  return &_impl_.model_stats_;
}
inline const ::inference::ModelStatistics& ModelStatisticsResponse::_internal_model_stats(int index) const {
  return _impl_.model_stats_.Get(index);
}
inline const ::inference::ModelStatistics& ModelStatisticsResponse::model_stats(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStatisticsResponse.model_stats)
  return _internal_model_stats(index);
}
inline ::inference::ModelStatistics* ModelStatisticsResponse::_internal_add_model_stats() {
  return _impl_.model_stats_.Add();
}
inline ::inference::ModelStatistics* ModelStatisticsResponse::add_model_stats() {
  ::inference::ModelStatistics* _add = _internal_add_model_stats();
  // @@protoc_insertion_point(field_add:inference.ModelStatisticsResponse.model_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelStatistics >&
ModelStatisticsResponse::model_stats() const {
  // @@protoc_insertion_point(field_list:inference.ModelStatisticsResponse.model_stats)
  return _impl_.model_stats_;
}

// -------------------------------------------------------------------

// ModelStatistics

// string name = 1;
inline void ModelStatistics::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelStatistics::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatistics::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.name)
}
inline std::string* ModelStatistics::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatistics.name)
  return _s;
}
inline const std::string& ModelStatistics::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelStatistics::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatistics::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatistics::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelStatistics.name)
  return _impl_.name_.Release();
}
inline void ModelStatistics::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatistics.name)
}

// string version = 2;
inline void ModelStatistics::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ModelStatistics::version() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStatistics::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.version)
}
inline std::string* ModelStatistics::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelStatistics.version)
  return _s;
}
inline const std::string& ModelStatistics::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ModelStatistics::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStatistics::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStatistics::release_version() {
  // @@protoc_insertion_point(field_release:inference.ModelStatistics.version)
  return _impl_.version_.Release();
}
inline void ModelStatistics::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStatistics.version)
}

// uint64 last_inference = 3;
inline void ModelStatistics::clear_last_inference() {
  _impl_.last_inference_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_last_inference() const {
  return _impl_.last_inference_;
}
inline uint64_t ModelStatistics::last_inference() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.last_inference)
  return _internal_last_inference();
}
inline void ModelStatistics::_internal_set_last_inference(uint64_t value) {
  
  _impl_.last_inference_ = value;
}
inline void ModelStatistics::set_last_inference(uint64_t value) {
  _internal_set_last_inference(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.last_inference)
}

// uint64 inference_count = 4;
inline void ModelStatistics::clear_inference_count() {
  _impl_.inference_count_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_inference_count() const {
  return _impl_.inference_count_;
}
inline uint64_t ModelStatistics::inference_count() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.inference_count)
  return _internal_inference_count();
}
inline void ModelStatistics::_internal_set_inference_count(uint64_t value) {
  
  _impl_.inference_count_ = value;
}
inline void ModelStatistics::set_inference_count(uint64_t value) {
  _internal_set_inference_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.inference_count)
}

// uint64 execution_count = 5;
inline void ModelStatistics::clear_execution_count() {
  _impl_.execution_count_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_execution_count() const {
  return _impl_.execution_count_;
}
inline uint64_t ModelStatistics::execution_count() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.execution_count)
  return _internal_execution_count();
}
inline void ModelStatistics::_internal_set_execution_count(uint64_t value) {
  
  _impl_.execution_count_ = value;
}
inline void ModelStatistics::set_execution_count(uint64_t value) {
  _internal_set_execution_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.execution_count)
}

// uint64 inference_duration_ns = 6;
inline void ModelStatistics::clear_inference_duration_ns() {
  _impl_.inference_duration_ns_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_inference_duration_ns() const {
  return _impl_.inference_duration_ns_;
}
inline uint64_t ModelStatistics::inference_duration_ns() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.inference_duration_ns)
  return _internal_inference_duration_ns();
}
inline void ModelStatistics::_internal_set_inference_duration_ns(uint64_t value) {
  
  _impl_.inference_duration_ns_ = value;
}
inline void ModelStatistics::set_inference_duration_ns(uint64_t value) {
  _internal_set_inference_duration_ns(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.inference_duration_ns)
}

// uint64 queue_duration_ns = 7;
inline void ModelStatistics::clear_queue_duration_ns() {
  _impl_.queue_duration_ns_ = uint64_t{0u};
}
inline uint64_t ModelStatistics::_internal_queue_duration_ns() const {
  return _impl_.queue_duration_ns_;
}
inline uint64_t ModelStatistics::queue_duration_ns() const {
  // @@protoc_insertion_point(field_get:inference.ModelStatistics.queue_duration_ns)
  return _internal_queue_duration_ns();
}
inline void ModelStatistics::_internal_set_queue_duration_ns(uint64_t value) {
  
  _impl_.queue_duration_ns_ = value;
}
inline void ModelStatistics::set_queue_duration_ns(uint64_t value) {
  _internal_set_queue_duration_ns(value);
  // @@protoc_insertion_point(field_set:inference.ModelStatistics.queue_duration_ns)
}

// -------------------------------------------------------------------

// SystemSharedMemoryStatusRequest

// string name = 1;
inline void SystemSharedMemoryStatusRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryStatusRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryStatusRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusRequest.name)
}
inline std::string* SystemSharedMemoryStatusRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryStatusRequest.name)
  return _s;
}
inline const std::string& SystemSharedMemoryStatusRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryStatusRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryStatusRequest.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryStatusRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryStatusRequest.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SystemSharedMemoryStatusResponse

// map<string, .inference.SystemSharedMemoryStatusResponse_RegionStatus> regions = 1;
inline int SystemSharedMemoryStatusResponse::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int SystemSharedMemoryStatusResponse::regions_size() const {
  return _internal_regions_size();
}
inline void SystemSharedMemoryStatusResponse::clear_regions() {
  _impl_.regions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
SystemSharedMemoryStatusResponse::_internal_regions() const {
  return _impl_.regions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >&
SystemSharedMemoryStatusResponse::regions() const {
  // @@protoc_insertion_point(field_map:inference.SystemSharedMemoryStatusResponse.regions)
  return _internal_regions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
SystemSharedMemoryStatusResponse::_internal_mutable_regions() {
  return _impl_.regions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::SystemSharedMemoryStatusResponse_RegionStatus >*
SystemSharedMemoryStatusResponse::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_map:inference.SystemSharedMemoryStatusResponse.regions)
  return _internal_mutable_regions();
}

// -------------------------------------------------------------------

// SystemSharedMemoryStatusResponse_RegionStatus

// string name = 1;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse_RegionStatus.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryStatusResponse_RegionStatus::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse_RegionStatus.name)
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryStatusResponse_RegionStatus.name)
  return _s;
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryStatusResponse_RegionStatus.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryStatusResponse_RegionStatus.name)
}

// string key = 2;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::key() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse_RegionStatus.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryStatusResponse_RegionStatus::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse_RegionStatus.key)
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryStatusResponse_RegionStatus.key)
  return _s;
}
inline const std::string& SystemSharedMemoryStatusResponse_RegionStatus::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryStatusResponse_RegionStatus::release_key() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryStatusResponse_RegionStatus.key)
  return _impl_.key_.Release();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryStatusResponse_RegionStatus.key)
}

// uint64 size = 3;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::size() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse_RegionStatus.size)
  return _internal_size();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse_RegionStatus.size)
}

// uint64 offset = 4;
inline void SystemSharedMemoryStatusResponse_RegionStatus::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t SystemSharedMemoryStatusResponse_RegionStatus::offset() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryStatusResponse_RegionStatus.offset)
  return _internal_offset();
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void SystemSharedMemoryStatusResponse_RegionStatus::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryStatusResponse_RegionStatus.offset)
}

// -------------------------------------------------------------------

// SystemSharedMemoryRegisterRequest

// string name = 1;
inline void SystemSharedMemoryRegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryRegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryRegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.name)
}
inline std::string* SystemSharedMemoryRegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryRegisterRequest.name)
  return _s;
}
inline const std::string& SystemSharedMemoryRegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryRegisterRequest.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryRegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryRegisterRequest.name)
}

// string key = 2;
inline void SystemSharedMemoryRegisterRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryRegisterRequest::key() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryRegisterRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.key)
}
inline std::string* SystemSharedMemoryRegisterRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryRegisterRequest.key)
  return _s;
}
inline const std::string& SystemSharedMemoryRegisterRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryRegisterRequest::release_key() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryRegisterRequest.key)
  return _impl_.key_.Release();
}
inline void SystemSharedMemoryRegisterRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryRegisterRequest.key)
}

// uint64 offset = 3;
inline void SystemSharedMemoryRegisterRequest::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryRegisterRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t SystemSharedMemoryRegisterRequest::offset() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.offset)
  return _internal_offset();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void SystemSharedMemoryRegisterRequest::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.offset)
}

// uint64 byte_size = 4;
inline void SystemSharedMemoryRegisterRequest::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t SystemSharedMemoryRegisterRequest::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t SystemSharedMemoryRegisterRequest::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryRegisterRequest.byte_size)
  return _internal_byte_size();
}
inline void SystemSharedMemoryRegisterRequest::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void SystemSharedMemoryRegisterRequest::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryRegisterRequest.byte_size)
}

// -------------------------------------------------------------------

// SystemSharedMemoryRegisterResponse

// -------------------------------------------------------------------

// SystemSharedMemoryUnregisterRequest

// string name = 1;
inline void SystemSharedMemoryUnregisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SystemSharedMemoryUnregisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.SystemSharedMemoryUnregisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemSharedMemoryUnregisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.SystemSharedMemoryUnregisterRequest.name)
}
inline std::string* SystemSharedMemoryUnregisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.SystemSharedMemoryUnregisterRequest.name)
  return _s;
}
inline const std::string& SystemSharedMemoryUnregisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SystemSharedMemoryUnregisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryUnregisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemSharedMemoryUnregisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.SystemSharedMemoryUnregisterRequest.name)
  return _impl_.name_.Release();
}
inline void SystemSharedMemoryUnregisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.SystemSharedMemoryUnregisterRequest.name)
}

// -------------------------------------------------------------------

// SystemSharedMemoryUnregisterResponse

// -------------------------------------------------------------------

// CudaSharedMemoryStatusRequest

// string name = 1;
inline void CudaSharedMemoryStatusRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryStatusRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryStatusRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusRequest.name)
}
inline std::string* CudaSharedMemoryStatusRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryStatusRequest.name)
  return _s;
}
inline const std::string& CudaSharedMemoryStatusRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryStatusRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryStatusRequest.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryStatusRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryStatusRequest.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CudaSharedMemoryStatusResponse

// map<string, .inference.CudaSharedMemoryStatusResponse_RegionStatus> regions = 1;
inline int CudaSharedMemoryStatusResponse::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int CudaSharedMemoryStatusResponse::regions_size() const {
  return _internal_regions_size();
}
inline void CudaSharedMemoryStatusResponse::clear_regions() {
  _impl_.regions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
CudaSharedMemoryStatusResponse::_internal_regions() const {
  return _impl_.regions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >&
CudaSharedMemoryStatusResponse::regions() const {
  // @@protoc_insertion_point(field_map:inference.CudaSharedMemoryStatusResponse.regions)
  return _internal_regions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
CudaSharedMemoryStatusResponse::_internal_mutable_regions() {
  return _impl_.regions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::CudaSharedMemoryStatusResponse_RegionStatus >*
CudaSharedMemoryStatusResponse::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_map:inference.CudaSharedMemoryStatusResponse.regions)
  return _internal_mutable_regions();
}

// -------------------------------------------------------------------

// CudaSharedMemoryStatusResponse_RegionStatus

// string name = 1;
inline void CudaSharedMemoryStatusResponse_RegionStatus::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryStatusResponse_RegionStatus::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusResponse_RegionStatus.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryStatusResponse_RegionStatus::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusResponse_RegionStatus.name)
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryStatusResponse_RegionStatus.name)
  return _s;
}
inline const std::string& CudaSharedMemoryStatusResponse_RegionStatus::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryStatusResponse_RegionStatus.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryStatusResponse_RegionStatus.name)
}

// int64 device_id = 2;
inline void CudaSharedMemoryStatusResponse_RegionStatus::clear_device_id() {
  _impl_.device_id_ = int64_t{0};
}
inline int64_t CudaSharedMemoryStatusResponse_RegionStatus::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int64_t CudaSharedMemoryStatusResponse_RegionStatus::device_id() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusResponse_RegionStatus.device_id)
  return _internal_device_id();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::_internal_set_device_id(int64_t value) {
  
  _impl_.device_id_ = value;
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::set_device_id(int64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusResponse_RegionStatus.device_id)
}

// bytes cuda_ipc_handle = 3;
inline void CudaSharedMemoryStatusResponse_RegionStatus::clear_cuda_ipc_handle() {
  _impl_.cuda_ipc_handle_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryStatusResponse_RegionStatus::cuda_ipc_handle() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusResponse_RegionStatus.cuda_ipc_handle)
  return _internal_cuda_ipc_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryStatusResponse_RegionStatus::set_cuda_ipc_handle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cuda_ipc_handle_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusResponse_RegionStatus.cuda_ipc_handle)
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::mutable_cuda_ipc_handle() {
  std::string* _s = _internal_mutable_cuda_ipc_handle();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryStatusResponse_RegionStatus.cuda_ipc_handle)
  return _s;
}
inline const std::string& CudaSharedMemoryStatusResponse_RegionStatus::_internal_cuda_ipc_handle() const {
  return _impl_.cuda_ipc_handle_.Get();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::_internal_set_cuda_ipc_handle(const std::string& value) {
  
  _impl_.cuda_ipc_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::_internal_mutable_cuda_ipc_handle() {
  
  return _impl_.cuda_ipc_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryStatusResponse_RegionStatus::release_cuda_ipc_handle() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryStatusResponse_RegionStatus.cuda_ipc_handle)
  return _impl_.cuda_ipc_handle_.Release();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::set_allocated_cuda_ipc_handle(std::string* cuda_ipc_handle) {
  if (cuda_ipc_handle != nullptr) {
    
  } else {
    
  }
  _impl_.cuda_ipc_handle_.SetAllocated(cuda_ipc_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cuda_ipc_handle_.IsDefault()) {
    _impl_.cuda_ipc_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryStatusResponse_RegionStatus.cuda_ipc_handle)
}

// uint64 byte_size = 4;
inline void CudaSharedMemoryStatusResponse_RegionStatus::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t CudaSharedMemoryStatusResponse_RegionStatus::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t CudaSharedMemoryStatusResponse_RegionStatus::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryStatusResponse_RegionStatus.byte_size)
  return _internal_byte_size();
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void CudaSharedMemoryStatusResponse_RegionStatus::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryStatusResponse_RegionStatus.byte_size)
}

// -------------------------------------------------------------------

// CudaSharedMemoryRegisterRequest

// string name = 1;
inline void CudaSharedMemoryRegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryRegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryRegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.name)
}
inline std::string* CudaSharedMemoryRegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryRegisterRequest.name)
  return _s;
}
inline const std::string& CudaSharedMemoryRegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryRegisterRequest.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryRegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryRegisterRequest.name)
}

// bytes raw_handle = 2;
inline void CudaSharedMemoryRegisterRequest::clear_raw_handle() {
  _impl_.raw_handle_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryRegisterRequest::raw_handle() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.raw_handle)
  return _internal_raw_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryRegisterRequest::set_raw_handle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_handle_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.raw_handle)
}
inline std::string* CudaSharedMemoryRegisterRequest::mutable_raw_handle() {
  std::string* _s = _internal_mutable_raw_handle();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryRegisterRequest.raw_handle)
  return _s;
}
inline const std::string& CudaSharedMemoryRegisterRequest::_internal_raw_handle() const {
  return _impl_.raw_handle_.Get();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_raw_handle(const std::string& value) {
  
  _impl_.raw_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::_internal_mutable_raw_handle() {
  
  return _impl_.raw_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryRegisterRequest::release_raw_handle() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryRegisterRequest.raw_handle)
  return _impl_.raw_handle_.Release();
}
inline void CudaSharedMemoryRegisterRequest::set_allocated_raw_handle(std::string* raw_handle) {
  if (raw_handle != nullptr) {
    
  } else {
    
  }
  _impl_.raw_handle_.SetAllocated(raw_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_handle_.IsDefault()) {
    _impl_.raw_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryRegisterRequest.raw_handle)
}

// int64 device_id = 3;
inline void CudaSharedMemoryRegisterRequest::clear_device_id() {
  _impl_.device_id_ = int64_t{0};
}
inline int64_t CudaSharedMemoryRegisterRequest::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int64_t CudaSharedMemoryRegisterRequest::device_id() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.device_id)
  return _internal_device_id();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_device_id(int64_t value) {
  
  _impl_.device_id_ = value;
}
inline void CudaSharedMemoryRegisterRequest::set_device_id(int64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.device_id)
}

// uint64 byte_size = 4;
inline void CudaSharedMemoryRegisterRequest::clear_byte_size() {
  _impl_.byte_size_ = uint64_t{0u};
}
inline uint64_t CudaSharedMemoryRegisterRequest::_internal_byte_size() const {
  return _impl_.byte_size_;
}
inline uint64_t CudaSharedMemoryRegisterRequest::byte_size() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryRegisterRequest.byte_size)
  return _internal_byte_size();
}
inline void CudaSharedMemoryRegisterRequest::_internal_set_byte_size(uint64_t value) {
  
  _impl_.byte_size_ = value;
}
inline void CudaSharedMemoryRegisterRequest::set_byte_size(uint64_t value) {
  _internal_set_byte_size(value);
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryRegisterRequest.byte_size)
}

// -------------------------------------------------------------------

// CudaSharedMemoryRegisterResponse

// -------------------------------------------------------------------

// CudaSharedMemoryUnregisterRequest

// string name = 1;
inline void CudaSharedMemoryUnregisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CudaSharedMemoryUnregisterRequest::name() const {
  // @@protoc_insertion_point(field_get:inference.CudaSharedMemoryUnregisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CudaSharedMemoryUnregisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.CudaSharedMemoryUnregisterRequest.name)
}
inline std::string* CudaSharedMemoryUnregisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.CudaSharedMemoryUnregisterRequest.name)
  return _s;
}
inline const std::string& CudaSharedMemoryUnregisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CudaSharedMemoryUnregisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryUnregisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CudaSharedMemoryUnregisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:inference.CudaSharedMemoryUnregisterRequest.name)
  return _impl_.name_.Release();
}
inline void CudaSharedMemoryUnregisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.CudaSharedMemoryUnregisterRequest.name)
}

// -------------------------------------------------------------------

// CudaSharedMemoryUnregisterResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelInferRequest

// string model_name = 1;
inline void ModelInferRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelInferRequest::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.model_name)
}
inline std::string* ModelInferRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.model_name)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelInferRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelInferRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.model_name)
}

// string model_version = 2;
inline void ModelInferRequest::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& ModelInferRequest::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.model_version)
}
inline std::string* ModelInferRequest::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.model_version)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void ModelInferRequest::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest::release_model_version() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.model_version)
  return _impl_.model_version_.Release();
}
inline void ModelInferRequest::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.model_version)
}

// string id = 3;
inline void ModelInferRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelInferRequest::id() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.id)
}
inline std::string* ModelInferRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.id)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelInferRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferRequest::release_id() {
  // @@protoc_insertion_point(field_release:inference.ModelInferRequest.id)
  return _impl_.id_.Release();
}
inline void ModelInferRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferRequest.id)
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelInferRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelInferRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelInferRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferRequest::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelInferRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelInferRequest.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.InferInputTensor inputs = 5;
inline int ModelInferRequest::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int ModelInferRequest::inputs_size() const {
  return _internal_inputs_size();
}
inline void ModelInferRequest::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::inference::InferInputTensor* ModelInferRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >*
ModelInferRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferRequest.inputs)
  return &_impl_.inputs_;
}
inline const ::inference::InferInputTensor& ModelInferRequest::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::inference::InferInputTensor& ModelInferRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.inputs)
  return _internal_inputs(index);
}
inline ::inference::InferInputTensor* ModelInferRequest::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::inference::InferInputTensor* ModelInferRequest::add_inputs() {
  ::inference::InferInputTensor* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >&
ModelInferRequest::inputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferRequest.inputs)
  return _impl_.inputs_;
}

// repeated .inference.InferRequestedOutputTensor outputs = 6;
inline int ModelInferRequest::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelInferRequest::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelInferRequest::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::InferRequestedOutputTensor* ModelInferRequest::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >*
ModelInferRequest::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferRequest.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::InferRequestedOutputTensor& ModelInferRequest::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::InferRequestedOutputTensor& ModelInferRequest::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.outputs)
  return _internal_outputs(index);
}
inline ::inference::InferRequestedOutputTensor* ModelInferRequest::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::InferRequestedOutputTensor* ModelInferRequest::add_outputs() {
  ::inference::InferRequestedOutputTensor* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >&
ModelInferRequest::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferRequest.outputs)
  return _impl_.outputs_;
}

// repeated bytes raw_input_contents = 7;
inline int ModelInferRequest::_internal_raw_input_contents_size() const {
  return _impl_.raw_input_contents_.size();
}
inline int ModelInferRequest::raw_input_contents_size() const {
  return _internal_raw_input_contents_size();
}
inline void ModelInferRequest::clear_raw_input_contents() {
  _impl_.raw_input_contents_.Clear();
}
inline std::string* ModelInferRequest::add_raw_input_contents() {
  std::string* _s = _internal_add_raw_input_contents();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelInferRequest.raw_input_contents)
  return _s;
}
inline const std::string& ModelInferRequest::_internal_raw_input_contents(int index) const {
  return _impl_.raw_input_contents_.Get(index);
}
inline const std::string& ModelInferRequest::raw_input_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferRequest.raw_input_contents)
  return _internal_raw_input_contents(index);
}
inline std::string* ModelInferRequest::mutable_raw_input_contents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferRequest.raw_input_contents)
  return _impl_.raw_input_contents_.Mutable(index);
}
inline void ModelInferRequest::set_raw_input_contents(int index, const std::string& value) {
  _impl_.raw_input_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::set_raw_input_contents(int index, std::string&& value) {
  _impl_.raw_input_contents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::set_raw_input_contents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_input_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::set_raw_input_contents(int index, const void* value, size_t size) {
  _impl_.raw_input_contents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInferRequest.raw_input_contents)
}
inline std::string* ModelInferRequest::_internal_add_raw_input_contents() {
  return _impl_.raw_input_contents_.Add();
}
inline void ModelInferRequest::add_raw_input_contents(const std::string& value) {
  _impl_.raw_input_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::add_raw_input_contents(std::string&& value) {
  _impl_.raw_input_contents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::add_raw_input_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_input_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelInferRequest.raw_input_contents)
}
inline void ModelInferRequest::add_raw_input_contents(const void* value, size_t size) {
  _impl_.raw_input_contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelInferRequest.raw_input_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInferRequest::raw_input_contents() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferRequest.raw_input_contents)
  return _impl_.raw_input_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInferRequest::mutable_raw_input_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferRequest.raw_input_contents)
  return &_impl_.raw_input_contents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelInferResponse

// string model_name = 1;
inline void ModelInferResponse::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelInferResponse::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.model_name)
}
inline std::string* ModelInferResponse::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.model_name)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelInferResponse::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelInferResponse::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.model_name)
}

// string model_version = 2;
inline void ModelInferResponse::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& ModelInferResponse::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.model_version)
}
inline std::string* ModelInferResponse::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.model_version)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void ModelInferResponse::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse::release_model_version() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.model_version)
  return _impl_.model_version_.Release();
}
inline void ModelInferResponse::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.model_version)
}

// string id = 3;
inline void ModelInferResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelInferResponse::id() const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInferResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.id)
}
inline std::string* ModelInferResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.id)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelInferResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInferResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInferResponse::release_id() {
  // @@protoc_insertion_point(field_release:inference.ModelInferResponse.id)
  return _impl_.id_.Release();
}
inline void ModelInferResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInferResponse.id)
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelInferResponse::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelInferResponse::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelInferResponse::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferResponse::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelInferResponse::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelInferResponse.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferResponse::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelInferResponse::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelInferResponse.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.InferOutputTensor outputs = 5;
inline int ModelInferResponse::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelInferResponse::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelInferResponse::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::InferOutputTensor* ModelInferResponse::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >*
ModelInferResponse::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferResponse.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::InferOutputTensor& ModelInferResponse::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::InferOutputTensor& ModelInferResponse::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.outputs)
  return _internal_outputs(index);
}
inline ::inference::InferOutputTensor* ModelInferResponse::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::InferOutputTensor* ModelInferResponse::add_outputs() {
  ::inference::InferOutputTensor* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelInferResponse.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >&
ModelInferResponse::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferResponse.outputs)
  return _impl_.outputs_;
}

// repeated bytes raw_output_contents = 6;
inline int ModelInferResponse::_internal_raw_output_contents_size() const {
  return _impl_.raw_output_contents_.size();
}
inline int ModelInferResponse::raw_output_contents_size() const {
  return _internal_raw_output_contents_size();
}
inline void ModelInferResponse::clear_raw_output_contents() {
  _impl_.raw_output_contents_.Clear();
}
inline std::string* ModelInferResponse::add_raw_output_contents() {
  std::string* _s = _internal_add_raw_output_contents();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelInferResponse.raw_output_contents)
  return _s;
}
inline const std::string& ModelInferResponse::_internal_raw_output_contents(int index) const {
  return _impl_.raw_output_contents_.Get(index);
}
inline const std::string& ModelInferResponse::raw_output_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInferResponse.raw_output_contents)
  return _internal_raw_output_contents(index);
}
inline std::string* ModelInferResponse::mutable_raw_output_contents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInferResponse.raw_output_contents)
  return _impl_.raw_output_contents_.Mutable(index);
}
inline void ModelInferResponse::set_raw_output_contents(int index, const std::string& value) {
  _impl_.raw_output_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::set_raw_output_contents(int index, std::string&& value) {
  _impl_.raw_output_contents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::set_raw_output_contents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_output_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::set_raw_output_contents(int index, const void* value, size_t size) {
  _impl_.raw_output_contents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInferResponse.raw_output_contents)
}
inline std::string* ModelInferResponse::_internal_add_raw_output_contents() {
  return _impl_.raw_output_contents_.Add();
}
inline void ModelInferResponse::add_raw_output_contents(const std::string& value) {
  _impl_.raw_output_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::add_raw_output_contents(std::string&& value) {
  _impl_.raw_output_contents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::add_raw_output_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_output_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelInferResponse.raw_output_contents)
}
inline void ModelInferResponse::add_raw_output_contents(const void* value, size_t size) {
  _impl_.raw_output_contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelInferResponse.raw_output_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInferResponse::raw_output_contents() const {
  // @@protoc_insertion_point(field_list:inference.ModelInferResponse.raw_output_contents)
  return _impl_.raw_output_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInferResponse::mutable_raw_output_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInferResponse.raw_output_contents)
  return &_impl_.raw_output_contents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelStreamInferRequest

// string model_name = 1;
inline void ModelStreamInferRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelStreamInferRequest::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStreamInferRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferRequest.model_name)
}
inline std::string* ModelStreamInferRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferRequest.model_name)
  return _s;
}
inline const std::string& ModelStreamInferRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelStreamInferRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStreamInferRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStreamInferRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelStreamInferRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferRequest.model_name)
}

// string model_version = 2;
inline void ModelStreamInferRequest::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& ModelStreamInferRequest::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferRequest.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStreamInferRequest::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferRequest.model_version)
}
inline std::string* ModelStreamInferRequest::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferRequest.model_version)
  return _s;
}
inline const std::string& ModelStreamInferRequest::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void ModelStreamInferRequest::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStreamInferRequest::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStreamInferRequest::release_model_version() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferRequest.model_version)
  return _impl_.model_version_.Release();
}
inline void ModelStreamInferRequest::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferRequest.model_version)
}

// string id = 3;
inline void ModelStreamInferRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelStreamInferRequest::id() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStreamInferRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferRequest.id)
}
inline std::string* ModelStreamInferRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferRequest.id)
  return _s;
}
inline const std::string& ModelStreamInferRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelStreamInferRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStreamInferRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStreamInferRequest::release_id() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferRequest.id)
  return _impl_.id_.Release();
}
inline void ModelStreamInferRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferRequest.id)
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelStreamInferRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelStreamInferRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelStreamInferRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelStreamInferRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelStreamInferRequest::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelStreamInferRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelStreamInferRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelStreamInferRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelStreamInferRequest.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.InferInputTensor inputs = 5;
inline int ModelStreamInferRequest::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int ModelStreamInferRequest::inputs_size() const {
  return _internal_inputs_size();
}
inline void ModelStreamInferRequest::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::inference::InferInputTensor* ModelStreamInferRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferRequest.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >*
ModelStreamInferRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStreamInferRequest.inputs)
  return &_impl_.inputs_;
}
inline const ::inference::InferInputTensor& ModelStreamInferRequest::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::inference::InferInputTensor& ModelStreamInferRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferRequest.inputs)
  return _internal_inputs(index);
}
inline ::inference::InferInputTensor* ModelStreamInferRequest::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::inference::InferInputTensor* ModelStreamInferRequest::add_inputs() {
  ::inference::InferInputTensor* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:inference.ModelStreamInferRequest.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferInputTensor >&
ModelStreamInferRequest::inputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelStreamInferRequest.inputs)
  return _impl_.inputs_;
}

// repeated .inference.InferRequestedOutputTensor outputs = 6;
inline int ModelStreamInferRequest::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelStreamInferRequest::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelStreamInferRequest::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::InferRequestedOutputTensor* ModelStreamInferRequest::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferRequest.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >*
ModelStreamInferRequest::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStreamInferRequest.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::InferRequestedOutputTensor& ModelStreamInferRequest::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::InferRequestedOutputTensor& ModelStreamInferRequest::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferRequest.outputs)
  return _internal_outputs(index);
}
inline ::inference::InferRequestedOutputTensor* ModelStreamInferRequest::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::InferRequestedOutputTensor* ModelStreamInferRequest::add_outputs() {
  ::inference::InferRequestedOutputTensor* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelStreamInferRequest.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferRequestedOutputTensor >&
ModelStreamInferRequest::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelStreamInferRequest.outputs)
  return _impl_.outputs_;
}

// repeated bytes raw_input_contents = 7;
inline int ModelStreamInferRequest::_internal_raw_input_contents_size() const {
  return _impl_.raw_input_contents_.size();
}
inline int ModelStreamInferRequest::raw_input_contents_size() const {
  return _internal_raw_input_contents_size();
}
inline void ModelStreamInferRequest::clear_raw_input_contents() {
  _impl_.raw_input_contents_.Clear();
}
inline std::string* ModelStreamInferRequest::add_raw_input_contents() {
  std::string* _s = _internal_add_raw_input_contents();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelStreamInferRequest.raw_input_contents)
  return _s;
}
inline const std::string& ModelStreamInferRequest::_internal_raw_input_contents(int index) const {
  return _impl_.raw_input_contents_.Get(index);
}
inline const std::string& ModelStreamInferRequest::raw_input_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferRequest.raw_input_contents)
  return _internal_raw_input_contents(index);
}
inline std::string* ModelStreamInferRequest::mutable_raw_input_contents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferRequest.raw_input_contents)
  return _impl_.raw_input_contents_.Mutable(index);
}
inline void ModelStreamInferRequest::set_raw_input_contents(int index, const std::string& value) {
  _impl_.raw_input_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferRequest.raw_input_contents)
}
inline void ModelStreamInferRequest::set_raw_input_contents(int index, std::string&& value) {
  _impl_.raw_input_contents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferRequest.raw_input_contents)
}
inline void ModelStreamInferRequest::set_raw_input_contents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_input_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelStreamInferRequest.raw_input_contents)
}
inline void ModelStreamInferRequest::set_raw_input_contents(int index, const void* value, size_t size) {
  _impl_.raw_input_contents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelStreamInferRequest.raw_input_contents)
}
inline std::string* ModelStreamInferRequest::_internal_add_raw_input_contents() {
  return _impl_.raw_input_contents_.Add();
}
inline void ModelStreamInferRequest::add_raw_input_contents(const std::string& value) {
  _impl_.raw_input_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelStreamInferRequest.raw_input_contents)
}
inline void ModelStreamInferRequest::add_raw_input_contents(std::string&& value) {
  _impl_.raw_input_contents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelStreamInferRequest.raw_input_contents)
}
inline void ModelStreamInferRequest::add_raw_input_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_input_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelStreamInferRequest.raw_input_contents)
}
inline void ModelStreamInferRequest::add_raw_input_contents(const void* value, size_t size) {
  _impl_.raw_input_contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelStreamInferRequest.raw_input_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelStreamInferRequest::raw_input_contents() const {
  // @@protoc_insertion_point(field_list:inference.ModelStreamInferRequest.raw_input_contents)
  return _impl_.raw_input_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelStreamInferRequest::mutable_raw_input_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStreamInferRequest.raw_input_contents)
  return &_impl_.raw_input_contents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelStreamInferResponse

// string model_name = 1;
inline void ModelStreamInferResponse::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelStreamInferResponse::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferResponse.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStreamInferResponse::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferResponse.model_name)
}
inline std::string* ModelStreamInferResponse::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferResponse.model_name)
  return _s;
}
inline const std::string& ModelStreamInferResponse::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void ModelStreamInferResponse::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferResponse.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelStreamInferResponse::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferResponse.model_name)
}

// string model_version = 2;
inline void ModelStreamInferResponse::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& ModelStreamInferResponse::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferResponse.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStreamInferResponse::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferResponse.model_version)
}
inline std::string* ModelStreamInferResponse::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferResponse.model_version)
  return _s;
}
inline const std::string& ModelStreamInferResponse::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void ModelStreamInferResponse::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::release_model_version() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferResponse.model_version)
  return _impl_.model_version_.Release();
}
inline void ModelStreamInferResponse::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferResponse.model_version)
}

// string id = 3;
inline void ModelStreamInferResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelStreamInferResponse::id() const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelStreamInferResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferResponse.id)
}
inline std::string* ModelStreamInferResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferResponse.id)
  return _s;
}
inline const std::string& ModelStreamInferResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelStreamInferResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelStreamInferResponse::release_id() {
  // @@protoc_insertion_point(field_release:inference.ModelStreamInferResponse.id)
  return _impl_.id_.Release();
}
inline void ModelStreamInferResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.ModelStreamInferResponse.id)
}

// map<string, .inference.InferParameter> parameters = 4;
inline int ModelStreamInferResponse::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ModelStreamInferResponse::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelStreamInferResponse::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelStreamInferResponse::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
ModelStreamInferResponse::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelStreamInferResponse.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelStreamInferResponse::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
ModelStreamInferResponse::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelStreamInferResponse.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.InferOutputTensor outputs = 5;
inline int ModelStreamInferResponse::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int ModelStreamInferResponse::outputs_size() const {
  return _internal_outputs_size();
}
inline void ModelStreamInferResponse::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::inference::InferOutputTensor* ModelStreamInferResponse::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferResponse.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >*
ModelStreamInferResponse::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStreamInferResponse.outputs)
  return &_impl_.outputs_;
}
inline const ::inference::InferOutputTensor& ModelStreamInferResponse::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::inference::InferOutputTensor& ModelStreamInferResponse::outputs(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferResponse.outputs)
  return _internal_outputs(index);
}
inline ::inference::InferOutputTensor* ModelStreamInferResponse::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::inference::InferOutputTensor* ModelStreamInferResponse::add_outputs() {
  ::inference::InferOutputTensor* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:inference.ModelStreamInferResponse.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::InferOutputTensor >&
ModelStreamInferResponse::outputs() const {
  // @@protoc_insertion_point(field_list:inference.ModelStreamInferResponse.outputs)
  return _impl_.outputs_;
}

// repeated bytes raw_output_contents = 6;
inline int ModelStreamInferResponse::_internal_raw_output_contents_size() const {
  return _impl_.raw_output_contents_.size();
}
inline int ModelStreamInferResponse::raw_output_contents_size() const {
  return _internal_raw_output_contents_size();
}
inline void ModelStreamInferResponse::clear_raw_output_contents() {
  _impl_.raw_output_contents_.Clear();
}
inline std::string* ModelStreamInferResponse::add_raw_output_contents() {
  std::string* _s = _internal_add_raw_output_contents();
  // @@protoc_insertion_point(field_add_mutable:inference.ModelStreamInferResponse.raw_output_contents)
  return _s;
}
inline const std::string& ModelStreamInferResponse::_internal_raw_output_contents(int index) const {
  return _impl_.raw_output_contents_.Get(index);
}
inline const std::string& ModelStreamInferResponse::raw_output_contents(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelStreamInferResponse.raw_output_contents)
  return _internal_raw_output_contents(index);
}
inline std::string* ModelStreamInferResponse::mutable_raw_output_contents(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelStreamInferResponse.raw_output_contents)
  return _impl_.raw_output_contents_.Mutable(index);
}
inline void ModelStreamInferResponse::set_raw_output_contents(int index, const std::string& value) {
  _impl_.raw_output_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferResponse.raw_output_contents)
}
inline void ModelStreamInferResponse::set_raw_output_contents(int index, std::string&& value) {
  _impl_.raw_output_contents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:inference.ModelStreamInferResponse.raw_output_contents)
}
inline void ModelStreamInferResponse::set_raw_output_contents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_output_contents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelStreamInferResponse.raw_output_contents)
}
inline void ModelStreamInferResponse::set_raw_output_contents(int index, const void* value, size_t size) {
  _impl_.raw_output_contents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelStreamInferResponse.raw_output_contents)
}
inline std::string* ModelStreamInferResponse::_internal_add_raw_output_contents() {
  return _impl_.raw_output_contents_.Add();
}
inline void ModelStreamInferResponse::add_raw_output_contents(const std::string& value) {
  _impl_.raw_output_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelStreamInferResponse.raw_output_contents)
}
inline void ModelStreamInferResponse::add_raw_output_contents(std::string&& value) {
  _impl_.raw_output_contents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelStreamInferResponse.raw_output_contents)
}
inline void ModelStreamInferResponse::add_raw_output_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_output_contents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelStreamInferResponse.raw_output_contents)
}
inline void ModelStreamInferResponse::add_raw_output_contents(const void* value, size_t size) {
  _impl_.raw_output_contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelStreamInferResponse.raw_output_contents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelStreamInferResponse::raw_output_contents() const {
  // @@protoc_insertion_point(field_list:inference.ModelStreamInferResponse.raw_output_contents)
  return _impl_.raw_output_contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelStreamInferResponse::mutable_raw_output_contents() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelStreamInferResponse.raw_output_contents)
  return &_impl_.raw_output_contents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InferInputTensor

// string name = 1;
inline void InferInputTensor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& InferInputTensor::name() const {
  // @@protoc_insertion_point(field_get:inference.InferInputTensor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InferInputTensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.InferInputTensor.name)
}
inline std::string* InferInputTensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.InferInputTensor.name)
  return _s;
}
inline const std::string& InferInputTensor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InferInputTensor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InferInputTensor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* InferInputTensor::release_name() {
  // @@protoc_insertion_point(field_release:inference.InferInputTensor.name)
  return _impl_.name_.Release();
}
inline void InferInputTensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.InferInputTensor.name)
}

// string datatype = 2;
inline void InferInputTensor::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& InferInputTensor::datatype() const {
  // @@protoc_insertion_point(field_get:inference.InferInputTensor.datatype)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InferInputTensor::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.InferInputTensor.datatype)
}
inline std::string* InferInputTensor::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:inference.InferInputTensor.datatype)
  return _s;
}
inline const std::string& InferInputTensor::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void InferInputTensor::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* InferInputTensor::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* InferInputTensor::release_datatype() {
  // @@protoc_insertion_point(field_release:inference.InferInputTensor.datatype)
  return _impl_.datatype_.Release();
}
inline void InferInputTensor::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.InferInputTensor.datatype)
}

// repeated int64 shape = 3;
inline int InferInputTensor::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int InferInputTensor::shape_size() const {
  return _internal_shape_size();
}
inline void InferInputTensor::clear_shape() {
  _impl_.shape_.Clear();
}
inline int64_t InferInputTensor::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int64_t InferInputTensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferInputTensor.shape)
  return _internal_shape(index);
}
inline void InferInputTensor::set_shape(int index, int64_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferInputTensor.shape)
}
inline void InferInputTensor::_internal_add_shape(int64_t value) {
  _impl_.shape_.Add(value);
}
inline void InferInputTensor::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.InferInputTensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
InferInputTensor::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
InferInputTensor::shape() const {
  // @@protoc_insertion_point(field_list:inference.InferInputTensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
InferInputTensor::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
InferInputTensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferInputTensor.shape)
  return _internal_mutable_shape();
}

// map<string, .inference.InferParameter> parameters = 4;
inline int InferInputTensor::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int InferInputTensor::parameters_size() const {
  return _internal_parameters_size();
}
inline void InferInputTensor::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
InferInputTensor::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
InferInputTensor::parameters() const {
  // @@protoc_insertion_point(field_map:inference.InferInputTensor.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
InferInputTensor::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
InferInputTensor::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.InferInputTensor.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InferRequestedOutputTensor

// string name = 1;
inline void InferRequestedOutputTensor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& InferRequestedOutputTensor::name() const {
  // @@protoc_insertion_point(field_get:inference.InferRequestedOutputTensor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InferRequestedOutputTensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.InferRequestedOutputTensor.name)
}
inline std::string* InferRequestedOutputTensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.InferRequestedOutputTensor.name)
  return _s;
}
inline const std::string& InferRequestedOutputTensor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InferRequestedOutputTensor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InferRequestedOutputTensor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* InferRequestedOutputTensor::release_name() {
  // @@protoc_insertion_point(field_release:inference.InferRequestedOutputTensor.name)
  return _impl_.name_.Release();
}
inline void InferRequestedOutputTensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.InferRequestedOutputTensor.name)
}

// map<string, .inference.InferParameter> parameters = 2;
inline int InferRequestedOutputTensor::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int InferRequestedOutputTensor::parameters_size() const {
  return _internal_parameters_size();
}
inline void InferRequestedOutputTensor::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
InferRequestedOutputTensor::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
InferRequestedOutputTensor::parameters() const {
  // @@protoc_insertion_point(field_map:inference.InferRequestedOutputTensor.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
InferRequestedOutputTensor::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
InferRequestedOutputTensor::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.InferRequestedOutputTensor.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InferOutputTensor

// string name = 1;
inline void InferOutputTensor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& InferOutputTensor::name() const {
  // @@protoc_insertion_point(field_get:inference.InferOutputTensor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InferOutputTensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.InferOutputTensor.name)
}
inline std::string* InferOutputTensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:inference.InferOutputTensor.name)
  return _s;
}
inline const std::string& InferOutputTensor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InferOutputTensor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InferOutputTensor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* InferOutputTensor::release_name() {
  // @@protoc_insertion_point(field_release:inference.InferOutputTensor.name)
  return _impl_.name_.Release();
}
inline void InferOutputTensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.InferOutputTensor.name)
}

// string datatype = 2;
inline void InferOutputTensor::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& InferOutputTensor::datatype() const {
  // @@protoc_insertion_point(field_get:inference.InferOutputTensor.datatype)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InferOutputTensor::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.InferOutputTensor.datatype)
}
inline std::string* InferOutputTensor::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:inference.InferOutputTensor.datatype)
  return _s;
}
inline const std::string& InferOutputTensor::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void InferOutputTensor::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* InferOutputTensor::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* InferOutputTensor::release_datatype() {
  // @@protoc_insertion_point(field_release:inference.InferOutputTensor.datatype)
  return _impl_.datatype_.Release();
}
inline void InferOutputTensor::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:inference.InferOutputTensor.datatype)
}

// repeated int64 shape = 3;
inline int InferOutputTensor::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int InferOutputTensor::shape_size() const {
  return _internal_shape_size();
}
inline void InferOutputTensor::clear_shape() {
  _impl_.shape_.Clear();
}
inline int64_t InferOutputTensor::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int64_t InferOutputTensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.InferOutputTensor.shape)
  return _internal_shape(index);
}
inline void InferOutputTensor::set_shape(int index, int64_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.InferOutputTensor.shape)
}
inline void InferOutputTensor::_internal_add_shape(int64_t value) {
  _impl_.shape_.Add(value);
}
inline void InferOutputTensor::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.InferOutputTensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
InferOutputTensor::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
InferOutputTensor::shape() const {
  // @@protoc_insertion_point(field_list:inference.InferOutputTensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
InferOutputTensor::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
InferOutputTensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.InferOutputTensor.shape)
  return _internal_mutable_shape();
}

// map<string, .inference.InferParameter> parameters = 4;
inline int InferOutputTensor::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int InferOutputTensor::parameters_size() const {
  return _internal_parameters_size();
}
inline void InferOutputTensor::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
InferOutputTensor::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >&
InferOutputTensor::parameters() const {
  // @@protoc_insertion_point(field_map:inference.InferOutputTensor.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
InferOutputTensor::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::InferParameter >*
InferOutputTensor::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.InferOutputTensor.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// InferParameter

// bool bool_param = 1;
inline bool InferParameter::_internal_has_bool_param() const {
  return parameter_choice_case() == kBoolParam;
}
inline bool InferParameter::has_bool_param() const {
  return _internal_has_bool_param();
}
inline void InferParameter::set_has_bool_param() {
  _impl_._oneof_case_[0] = kBoolParam;
}
inline void InferParameter::clear_bool_param() {
  if (_internal_has_bool_param()) {
    _impl_.parameter_choice_.bool_param_ = false;
    clear_has_parameter_choice();
  }
}
inline bool InferParameter::_internal_bool_param() const {
  if (_internal_has_bool_param()) {
    return _impl_.parameter_choice_.bool_param_;
  }
  return false;
}
inline void InferParameter::_internal_set_bool_param(bool value) {
  if (!_internal_has_bool_param()) {
    clear_parameter_choice();
    set_has_bool_param();
  }
  _impl_.parameter_choice_.bool_param_ = value;
}
inline bool InferParameter::bool_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.bool_param)
  return _internal_bool_param();
}
inline void InferParameter::set_bool_param(bool value) {
  _internal_set_bool_param(value);
  // @@protoc_insertion_point(field_set:inference.InferParameter.bool_param)
}

// int64 int64_param = 2;
inline bool InferParameter::_internal_has_int64_param() const {
  return parameter_choice_case() == kInt64Param;
}
inline bool InferParameter::has_int64_param() const {
  return _internal_has_int64_param();
}
inline void InferParameter::set_has_int64_param() {
  _impl_._oneof_case_[0] = kInt64Param;
}
inline void InferParameter::clear_int64_param() {
  if (_internal_has_int64_param()) {
    _impl_.parameter_choice_.int64_param_ = int64_t{0};
    clear_has_parameter_choice();
  }
}
inline int64_t InferParameter::_internal_int64_param() const {
  if (_internal_has_int64_param()) {
    return _impl_.parameter_choice_.int64_param_;
  }
  return int64_t{0};
}
inline void InferParameter::_internal_set_int64_param(int64_t value) {
  if (!_internal_has_int64_param()) {
    clear_parameter_choice();
    set_has_int64_param();
  }
  _impl_.parameter_choice_.int64_param_ = value;
}
inline int64_t InferParameter::int64_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.int64_param)
  return _internal_int64_param();
}
inline void InferParameter::set_int64_param(int64_t value) {
  _internal_set_int64_param(value);
  // @@protoc_insertion_point(field_set:inference.InferParameter.int64_param)
}

// string string_param = 3;
inline bool InferParameter::_internal_has_string_param() const {
  return parameter_choice_case() == kStringParam;
}
inline bool InferParameter::has_string_param() const {
  return _internal_has_string_param();
}
inline void InferParameter::set_has_string_param() {
  _impl_._oneof_case_[0] = kStringParam;
}
inline void InferParameter::clear_string_param() {
  if (_internal_has_string_param()) {
    _impl_.parameter_choice_.string_param_.Destroy();
    clear_has_parameter_choice();
  }
}
inline const std::string& InferParameter::string_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.string_param)
  return _internal_string_param();
}
template <typename ArgT0, typename... ArgT>
inline void InferParameter::set_string_param(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inference.InferParameter.string_param)
}
inline std::string* InferParameter::mutable_string_param() {
  std::string* _s = _internal_mutable_string_param();
  // @@protoc_insertion_point(field_mutable:inference.InferParameter.string_param)
  return _s;
}
inline const std::string& InferParameter::_internal_string_param() const {
  if (_internal_has_string_param()) {
    return _impl_.parameter_choice_.string_param_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InferParameter::_internal_set_string_param(const std::string& value) {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  _impl_.parameter_choice_.string_param_.Set(value, GetArenaForAllocation());
}
inline std::string* InferParameter::_internal_mutable_string_param() {
  if (!_internal_has_string_param()) {
    clear_parameter_choice();
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitDefault();
  }
  return _impl_.parameter_choice_.string_param_.Mutable(      GetArenaForAllocation());
}
inline std::string* InferParameter::release_string_param() {
  // @@protoc_insertion_point(field_release:inference.InferParameter.string_param)
  if (_internal_has_string_param()) {
    clear_has_parameter_choice();
    return _impl_.parameter_choice_.string_param_.Release();
  } else {
    return nullptr;
  }
}
inline void InferParameter::set_allocated_string_param(std::string* string_param) {
  if (has_parameter_choice()) {
    clear_parameter_choice();
  }
  if (string_param != nullptr) {
    set_has_string_param();
    _impl_.parameter_choice_.string_param_.InitAllocated(string_param, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inference.InferParameter.string_param)
}

// double double_param = 4;
inline bool InferParameter::_internal_has_double_param() const {
  return parameter_choice_case() == kDoubleParam;
}
inline bool InferParameter::has_double_param() const {
  return _internal_has_double_param();
}
inline void InferParameter::set_has_double_param() {
  _impl_._oneof_case_[0] = kDoubleParam;
}
inline void InferParameter::clear_double_param() {
  if (_internal_has_double_param()) {
    _impl_.parameter_choice_.double_param_ = 0;
    clear_has_parameter_choice();
  }
}
inline double InferParameter::_internal_double_param() const {
  if (_internal_has_double_param()) {
    return _impl_.parameter_choice_.double_param_;
  }
  return 0;
}
inline void InferParameter::_internal_set_double_param(double value) {
  if (!_internal_has_double_param()) {
    clear_parameter_choice();
    set_has_double_param();
  }
  _impl_.parameter_choice_.double_param_ = value;
}
inline double InferParameter::double_param() const {
  // @@protoc_insertion_point(field_get:inference.InferParameter.double_param)
  return _internal_double_param();
}
inline void InferParameter::set_double_param(double value) {
  _internal_set_double_param(value);
  // @@protoc_insertion_point(field_set:inference.InferParameter.double_param)
}

inline bool InferParameter::has_parameter_choice() const {
  return parameter_choice_case() != PARAMETER_CHOICE_NOT_SET;
}
inline void InferParameter::clear_has_parameter_choice() {
  _impl_._oneof_case_[0] = PARAMETER_CHOICE_NOT_SET;
}
inline InferParameter::ParameterChoiceCase InferParameter::parameter_choice_case() const {
  return InferParameter::ParameterChoiceCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace inference

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpc_5fservice_2eproto
